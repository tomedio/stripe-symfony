{"0": {
    "doc": "Home",
    "title": "Stripe Bundle for Symfony",
    "content": "A Symfony bundle for integrating Stripe payments into your Symfony applications with Doctrine ORM and API Platform. Get Started View on GitHub . ",
    "url": "/stripe-symfony/#stripe-bundle-for-symfony",
    
    "relUrl": "/#stripe-bundle-for-symfony"
  },"1": {
    "doc": "Home",
    "title": "Overview",
    "content": "Stripe Bundle for Symfony provides a seamless integration between Stripe’s payment processing capabilities and your Symfony application. It’s designed to work with Doctrine ORM and API Platform, making it easy to add subscription-based payments, pay-per-action features, and prepaid credits to your SaaS application. Key Features . | Easy integration with Symfony, Doctrine ORM, and API Platform | Customer management with billing address support | Subscription management with trial periods | Invoice tracking and management | Webhook handling with Symfony events | Pay-per-action support (usage-based billing) | Prepaid credits system | Secure payment processing via Stripe Checkout | . Why Use This Bundle? . | Simplified Integration: Reduces the complexity of working directly with Stripe’s API | Symfony-Native: Uses Symfony’s event system, dependency injection, and other features | Flexible: Supports multiple payment models (subscriptions, pay-per-use, credits) | Secure: Leverages Stripe Checkout for secure payment processing | Maintainable: Well-structured code following SOLID principles | . ",
    "url": "/stripe-symfony/#overview",
    
    "relUrl": "/#overview"
  },"2": {
    "doc": "Home",
    "title": "Getting Started",
    "content": "Get up and running quickly with our installation guide. ",
    "url": "/stripe-symfony/#getting-started",
    
    "relUrl": "/#getting-started"
  },"3": {
    "doc": "Home",
    "title": "License",
    "content": "Stripe Bundle for Symfony is open-sourced software licensed under the MIT license. ",
    "url": "/stripe-symfony/#license",
    
    "relUrl": "/#license"
  },"4": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/stripe-symfony/",
    
    "relUrl": "/"
  },"5": {
    "doc": "API Reference",
    "title": "API Reference",
    "content": "This section provides detailed documentation for all the interfaces, services, and events provided by the Stripe Bundle. ",
    "url": "/stripe-symfony/docs/api-reference",
    
    "relUrl": "/docs/api-reference"
  },"6": {
    "doc": "API Reference",
    "title": "Reference Categories",
    "content": ". | Interfaces: Documentation for all interfaces that your application needs to implement | Services: Documentation for the services provided by the bundle | Events: Documentation for the events dispatched by the bundle | Enums: Documentation for the enumerations used in the bundle | Models: Documentation for the data models used in the bundle | . ",
    "url": "/stripe-symfony/docs/api-reference#reference-categories",
    
    "relUrl": "/docs/api-reference#reference-categories"
  },"7": {
    "doc": "Core Concepts",
    "title": "Core Concepts",
    "content": "This section explains the fundamental concepts and architecture of the Stripe Bundle. ",
    "url": "/stripe-symfony/docs/core-concepts",
    
    "relUrl": "/docs/core-concepts"
  },"8": {
    "doc": "Core Concepts",
    "title": "What You’ll Learn",
    "content": ". | The key entities and interfaces in the bundle | How the bundle integrates with Symfony, Doctrine, and API Platform | The event system used for communication between components | How data flows between your application, the bundle, and Stripe | . ",
    "url": "/stripe-symfony/docs/core-concepts#what-youll-learn",
    
    "relUrl": "/docs/core-concepts#what-youll-learn"
  },"9": {
    "doc": "Core Concepts",
    "title": "Architecture Overview",
    "content": "The Stripe Bundle is designed with a focus on flexibility, extensibility, and separation of concerns. It provides a layer of abstraction over the Stripe API that integrates seamlessly with Symfony applications while allowing for customization to fit your specific needs. Key Components . The bundle consists of several key components: . | Contracts (Interfaces): Define the data structures and behaviors that your application entities must implement | Services: Provide the core functionality for interacting with Stripe | Event System: Enables communication between components and with your application | Webhooks: Process events from Stripe and update your application accordingly | . ",
    "url": "/stripe-symfony/docs/core-concepts#architecture-overview",
    
    "relUrl": "/docs/core-concepts#architecture-overview"
  },"10": {
    "doc": "Core Concepts",
    "title": "Core Entities and Interfaces",
    "content": "The bundle defines several interfaces that your application entities should implement: . StripeUserInterface . Represents a user in your application who can be a Stripe customer. This interface extends Symfony’s UserInterface and adds methods for: . | Managing the Stripe customer ID | Handling billing information | Tracking subscriptions | Managing credit balances | . Your application’s User entity should implement this interface to integrate with Stripe. SubscriptionPlanInterface . Represents a subscription plan that users can subscribe to. It includes: . | Plan details (name, description) | Pricing information (amount, currency) | Billing interval (monthly, yearly) | Trial period settings | Stripe product and price IDs | . Your application can define multiple subscription plans with different features and pricing. SubscriptionInterface . Represents a user’s subscription to a plan. It tracks: . | The user and plan associated with the subscription | Subscription status (active, canceled, etc.) | Important dates (start date, end date, trial end date) | The Stripe subscription ID | . This interface allows your application to track which users are subscribed to which plans. StripeInvoiceInterface . Represents an invoice generated by Stripe. It includes: . | The user associated with the invoice | The subscription (if applicable) | Amount and currency | Status (paid, unpaid, etc.) | Important dates (invoice date, due date, paid date) | . Your application can store basic invoice information locally while fetching detailed information from Stripe when needed. CreditTransactionInterface . Represents a transaction for credits used in pay-per-action billing. It tracks: . | The user associated with the transaction | The amount of credits (positive for purchases, negative for usage) | Transaction type (purchase, usage) | Reference information (description, reference ID) | Monetary amount and currency (if applicable) | . This interface enables your application to implement a credit system for pay-per-action features. ",
    "url": "/stripe-symfony/docs/core-concepts#core-entities-and-interfaces",
    
    "relUrl": "/docs/core-concepts#core-entities-and-interfaces"
  },"11": {
    "doc": "Core Concepts",
    "title": "Services",
    "content": "The bundle provides several services that handle the interaction with Stripe: . StripeClient . A wrapper around the Stripe PHP SDK that provides: . | Error handling and logging | A simplified interface for executing Stripe API calls | Integration with Symfony’s logging system | . CustomerService . Manages Stripe customers and their relationship with your application users: . | Creates and updates customers in Stripe | Syncs customer data between your application and Stripe | Handles billing information and tax IDs | . SubscriptionService . Manages subscriptions and checkout sessions: . | Creates checkout sessions for subscription purchases | Syncs subscription data between your application and Stripe | Handles subscription cancellations and updates | . InvoiceService . Manages invoices and payments: . | Syncs invoice data between your application and Stripe | Handles invoice payments and refunds | Provides methods for retrieving invoice details | . CreditService . Manages credits for pay-per-action billing: . | Creates checkout sessions for credit purchases | Tracks credit usage and balances | Handles credit transactions | . UsageService . Manages usage records for metered billing: . | Records usage for pay-as-you-go features | Adds one-time charges to invoices | Retrieves usage history | . WebhookHandler . Processes webhooks from Stripe: . | Verifies webhook signatures | Dispatches events based on webhook type | Handles errors and logging | . ",
    "url": "/stripe-symfony/docs/core-concepts#services",
    
    "relUrl": "/docs/core-concepts#services"
  },"12": {
    "doc": "Core Concepts",
    "title": "Event System",
    "content": "The bundle uses Symfony’s event dispatcher to communicate between components and with your application. Events are dispatched for various actions, such as: . | Subscription created or updated | Invoice created or paid | Customer created or updated | Credit purchased or used | . Your application can listen to these events to implement custom logic, such as: . | Sending emails to users | Updating application state | Logging activity | Triggering additional processes | . ",
    "url": "/stripe-symfony/docs/core-concepts#event-system",
    
    "relUrl": "/docs/core-concepts#event-system"
  },"13": {
    "doc": "Core Concepts",
    "title": "Data Flow",
    "content": "The bundle manages the flow of data between your application, the bundle, and Stripe: . Application → Bundle → Stripe . When your application needs to interact with Stripe (e.g., create a subscription), it: . | Calls a method on one of the bundle’s services | The service prepares the data and makes the appropriate API call to Stripe | Stripe processes the request and returns a response | The service handles the response and updates your application entities | . Stripe → Bundle → Application . When Stripe needs to notify your application of an event (e.g., payment succeeded), it: . | Sends a webhook to your application’s webhook endpoint | The WebhookHandler verifies the webhook and creates an event | The event is dispatched to listeners in your application | Your application updates its state based on the event | . ",
    "url": "/stripe-symfony/docs/core-concepts#data-flow",
    
    "relUrl": "/docs/core-concepts#data-flow"
  },"14": {
    "doc": "Core Concepts",
    "title": "Integration Patterns",
    "content": "The bundle uses several patterns to integrate with your application: . Contract-Based Integration . The bundle defines interfaces that your application entities must implement. This allows the bundle to work with your entities without knowing their specific implementation details. Event-Based Communication . The bundle dispatches events that your application can listen to. This allows your application to react to changes in Stripe without tight coupling to the bundle. Symfony Integration . The bundle integrates with Symfony’s dependency injection, event dispatcher, and HTTP components to provide a seamless experience within your Symfony application. Doctrine Integration . The bundle provides interfaces for entities that can be implemented in your Doctrine entities, allowing for easy persistence of Stripe-related data. API Platform Integration . The bundle can expose Stripe-related resources through API Platform, allowing for easy creation of APIs for your frontend applications. ",
    "url": "/stripe-symfony/docs/core-concepts#integration-patterns",
    
    "relUrl": "/docs/core-concepts#integration-patterns"
  },"15": {
    "doc": "Core Concepts",
    "title": "Payment Flows",
    "content": "The bundle supports several payment flows: . Subscription-Based Billing . Users subscribe to plans and are billed regularly (monthly, yearly, etc.). The bundle handles: . | Creating checkout sessions for subscription purchases | Processing subscription webhooks | Tracking subscription status and renewal dates | Managing trial periods | . Pay-Per-Action Billing . Users are billed based on their usage of specific features. The bundle supports two approaches: . | Credit-Based: Users purchase credits that they can spend on actions | Metered Billing: Usage is tracked and billed at the end of the billing period | . Direct Checkout . Users are redirected to Stripe Checkout for payment, providing a secure and user-friendly payment experience. The bundle handles: . | Creating checkout sessions with the appropriate products and prices | Processing successful payment webhooks | Updating your application based on payment status | . ",
    "url": "/stripe-symfony/docs/core-concepts#payment-flows",
    
    "relUrl": "/docs/core-concepts#payment-flows"
  },"16": {
    "doc": "Features",
    "title": "Features",
    "content": "The Stripe Bundle provides a rich set of features to help you integrate Stripe payments into your Symfony application. ",
    "url": "/stripe-symfony/docs/features",
    
    "relUrl": "/docs/features"
  },"17": {
    "doc": "Features",
    "title": "Available Features",
    "content": ". | Subscription Management: Create, update, and manage subscription plans and customer subscriptions | Webhook Handling: Process Stripe webhook events to keep your application in sync with Stripe | Customer Management: Create and manage Stripe customers with billing address support | Invoice Tracking: Track and manage invoices for your customers | Pay-per-action Support: Implement usage-based billing for your API or services | Prepaid Credits System: Allow customers to purchase and use credits for your services | Secure Checkout: Use Stripe Checkout for secure payment processing | . ",
    "url": "/stripe-symfony/docs/features#available-features",
    
    "relUrl": "/docs/features#available-features"
  },"18": {
    "doc": "Pay-Per-Action",
    "title": "Pay-Per-Action with Credits",
    "content": " ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#pay-per-action-with-credits",
    
    "relUrl": "/docs/features/pay-per-action/#pay-per-action-with-credits"
  },"19": {
    "doc": "Pay-Per-Action",
    "title": "Table of contents",
    "content": ". | Overview | Setting Up the Credits System . | 1. Implement the Required Interfaces | 2. Create a Credit Package Entity | . | Using the Credit Service . | 1. Adding Credits | 2. Using Credits | 3. Checking Credit Balance | . | Creating a Credit Purchase Checkout | Handling Credit Purchase Webhooks | API Platform Integration | Frontend Integration | Best Practices | . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#table-of-contents",
    
    "relUrl": "/docs/features/pay-per-action/#table-of-contents"
  },"20": {
    "doc": "Pay-Per-Action",
    "title": "Overview",
    "content": "The Stripe Bundle provides a credits system that allows you to implement pay-per-action functionality in your SaaS application. This is useful for applications where users pay for specific actions or API calls rather than (or in addition to) a subscription. ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#overview",
    
    "relUrl": "/docs/features/pay-per-action/#overview"
  },"21": {
    "doc": "Pay-Per-Action",
    "title": "Setting Up the Credits System",
    "content": "1. Implement the Required Interfaces . First, make sure your User entity implements the StripeUserInterface and has a credits balance field: . &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Security\\Core\\User\\UserInterface as SymfonyUserInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; #[ORM\\Entity] class User implements SymfonyUserInterface, StripeUserInterface { // ... other properties #[ORM\\Column(type: 'integer')] private int $creditsBalance = 0; // ... other methods public function getCreditsBalance(): int { return $this-&gt;creditsBalance; } public function setCreditsBalance(int $creditsBalance): self { $this-&gt;creditsBalance = $creditsBalance; return $this; } } . Then, implement the CreditTransactionInterface for tracking credit transactions: . &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Contract\\CreditTransactionInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; use Tomedio\\StripeBundle\\Enum\\CreditTransactionType; use Tomedio\\StripeBundle\\Enum\\Currency; #[ORM\\Entity] class CreditTransaction implements CreditTransactionInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private ?int $id = null; #[ORM\\ManyToOne(targetEntity: User::class)] #[ORM\\JoinColumn(nullable: false)] private StripeUserInterface $user; #[ORM\\Column(type: 'integer')] private int $amount; #[ORM\\Column(type: 'integer')] private int $balanceAfter; #[ORM\\Column(type: 'string', length: 255)] private string $description; #[ORM\\Column(type: 'datetime')] private \\DateTimeInterface $transactionDate; #[ORM\\Column(type: 'string', length: 20, enumType: CreditTransactionType::class)] private CreditTransactionType $type; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $referenceId = null; #[ORM\\Column(type: 'integer', nullable: true)] private ?int $monetaryAmount = null; #[ORM\\Column(type: 'string', length: 3, nullable: true, enumType: Currency::class)] private ?Currency $currency = null; // Implement getters and setters for all properties // ... } . 2. Create a Credit Package Entity . Create an entity to represent credit packages that users can purchase: . &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Enum\\Currency; #[ORM\\Entity] class CreditPackage { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private ?int $id = null; #[ORM\\Column(type: 'string', length: 255)] private string $name; #[ORM\\Column(type: 'text', nullable: true)] private ?string $description = null; #[ORM\\Column(type: 'integer')] private int $credits; #[ORM\\Column(type: 'integer')] private int $price; #[ORM\\Column(type: 'string', length: 3, enumType: Currency::class)] private Currency $currency; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripeProductId = null; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripePriceId = null; // Getters and setters // ... } . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#setting-up-the-credits-system",
    
    "relUrl": "/docs/features/pay-per-action/#setting-up-the-credits-system"
  },"22": {
    "doc": "Pay-Per-Action",
    "title": "Using the Credit Service",
    "content": "The bundle provides a CreditService that you can use to manage user credits: . 1. Adding Credits . When a user purchases credits, you can add them to their balance: . &lt;?php namespace App\\Controller; use App\\Entity\\CreditPackage; use App\\Repository\\CreditPackageRepository; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Annotation\\Route; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Enum\\CreditTransactionType; use Tomedio\\StripeBundle\\Service\\CreditService; class CreditController extends AbstractController { private Security $security; private CreditService $creditService; private CreditPackageRepository $packageRepository; public function __construct( Security $security, CreditService $creditService, CreditPackageRepository $packageRepository ) { $this-&gt;security = $security; $this-&gt;creditService = $creditService; $this-&gt;packageRepository = $packageRepository; } #[Route('/credits/add/{packageId}', name: 'credits_add')] public function addCredits(int $packageId): Response { $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;redirectToRoute('app_login'); } $package = $this-&gt;packageRepository-&gt;find($packageId); if (!$package) { throw $this-&gt;createNotFoundException('Credit package not found'); } // Add credits to the user's balance $this-&gt;creditService-&gt;addCredits( $user, $package-&gt;getCredits(), 'Purchase of ' . $package-&gt;getName() . ' credit package', CreditTransactionType::PURCHASE, 'package_' . $package-&gt;getId(), $package-&gt;getPrice(), $package-&gt;getCurrency() ); $this-&gt;addFlash('success', $package-&gt;getCredits() . ' credits have been added to your account.'); return $this-&gt;redirectToRoute('credits_balance'); } } . 2. Using Credits . When a user performs an action that requires credits, you can deduct them from their balance: . &lt;?php namespace App\\Service; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Enum\\CreditTransactionType; use Tomedio\\StripeBundle\\Service\\CreditService; class ApiService { private Security $security; private CreditService $creditService; public function __construct( Security $security, CreditService $creditService ) { $this-&gt;security = $security; $this-&gt;creditService = $creditService; } public function performApiCall(string $endpoint, array $params): array { $user = $this-&gt;security-&gt;getUser(); if (!$user) { throw new \\Exception('User not authenticated'); } // Check if the user has enough credits $requiredCredits = $this-&gt;getRequiredCredits($endpoint); if ($user-&gt;getCreditsBalance() &lt; $requiredCredits) { throw new \\Exception('Not enough credits. Required: ' . $requiredCredits . ', Available: ' . $user-&gt;getCreditsBalance()); } // Use credits $creditsUsed = $this-&gt;creditService-&gt;useCredits( $user, $requiredCredits, 'API call to ' . $endpoint, CreditTransactionType::USAGE, 'api_' . $endpoint ); if ($creditsUsed &lt; $requiredCredits) { throw new \\Exception('Failed to use credits'); } // Perform the actual API call // ... return $result; } private function getRequiredCredits(string $endpoint): int { // Define credit costs for different endpoints $creditCosts = [ 'search' =&gt; 1, 'analyze' =&gt; 5, 'generate' =&gt; 10, ]; return $creditCosts[$endpoint] ?? 1; } } . 3. Checking Credit Balance . You can check a user’s credit balance: . &lt;?php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Annotation\\Route; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Service\\CreditService; class CreditController extends AbstractController { private Security $security; private CreditService $creditService; public function __construct( Security $security, CreditService $creditService ) { $this-&gt;security = $security; $this-&gt;creditService = $creditService; } #[Route('/credits/balance', name: 'credits_balance')] public function balance(): Response { $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;redirectToRoute('app_login'); } // Get the user's credit transactions $transactions = $this-&gt;creditService-&gt;getTransactions($user); return $this-&gt;render('credit/balance.html.twig', [ 'balance' =&gt; $user-&gt;getCreditsBalance(), 'transactions' =&gt; $transactions, ]); } } . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#using-the-credit-service",
    
    "relUrl": "/docs/features/pay-per-action/#using-the-credit-service"
  },"23": {
    "doc": "Pay-Per-Action",
    "title": "Creating a Credit Purchase Checkout",
    "content": "You can use the CreditService to create a checkout session for purchasing credits: . &lt;?php namespace App\\Controller; use App\\Repository\\CreditPackageRepository; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Annotation\\Route; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Service\\CreditService; use Tomedio\\StripeBundle\\Service\\CustomerService; class CreditController extends AbstractController { private Security $security; private CreditService $creditService; private CustomerService $customerService; private CreditPackageRepository $packageRepository; public function __construct( Security $security, CreditService $creditService, CustomerService $customerService, CreditPackageRepository $packageRepository ) { $this-&gt;security = $security; $this-&gt;creditService = $creditService; $this-&gt;customerService = $customerService; $this-&gt;packageRepository = $packageRepository; } #[Route('/credits/checkout/{packageId}', name: 'credits_checkout')] public function checkout(int $packageId): Response { $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;redirectToRoute('app_login'); } $package = $this-&gt;packageRepository-&gt;find($packageId); if (!$package) { throw $this-&gt;createNotFoundException('Credit package not found'); } // Ensure the user has a Stripe customer ID if (!$user-&gt;getStripeCustomerId()) { $this-&gt;customerService-&gt;getOrCreateCustomer($user); } // Create a checkout session for purchasing credits $checkoutUrl = $this-&gt;creditService-&gt;createCreditsCheckoutSession( $user, $package-&gt;getPrice(), $package-&gt;getCurrency(), $package-&gt;getCredits(), $package-&gt;getName() . ' - ' . $package-&gt;getCredits() . ' credits' ); return $this-&gt;redirect($checkoutUrl); } } . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#creating-a-credit-purchase-checkout",
    
    "relUrl": "/docs/features/pay-per-action/#creating-a-credit-purchase-checkout"
  },"24": {
    "doc": "Pay-Per-Action",
    "title": "Handling Credit Purchase Webhooks",
    "content": "When a user completes a credit purchase, you’ll receive a webhook event that you should handle: . &lt;?php namespace App\\EventSubscriber; use App\\Repository\\CreditPackageRepository; use App\\Repository\\UserRepository; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Tomedio\\StripeBundle\\Enum\\CreditTransactionType; use Tomedio\\StripeBundle\\Event\\StripeWebhookEvent; use Tomedio\\StripeBundle\\Service\\CreditService; class StripeWebhookSubscriber implements EventSubscriberInterface { private UserRepository $userRepository; private CreditPackageRepository $packageRepository; private CreditService $creditService; public function __construct( UserRepository $userRepository, CreditPackageRepository $packageRepository, CreditService $creditService ) { $this-&gt;userRepository = $userRepository; $this-&gt;packageRepository = $packageRepository; $this-&gt;creditService = $creditService; } public static function getSubscribedEvents(): array { return [ 'stripe.checkout_session_completed' =&gt; 'onCheckoutSessionCompleted', ]; } public function onCheckoutSessionCompleted(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $session = $stripeEvent-&gt;data-&gt;object; // Check if this is a credit purchase if ($session-&gt;mode !== 'payment' || !isset($session-&gt;metadata-&gt;package_id)) { return; } // Get the customer ID from the session $customerId = $session-&gt;customer; // Find the user by Stripe customer ID $user = $this-&gt;userRepository-&gt;findOneByStripeCustomerId($customerId); if (!$user) { return; } // Get the package ID and credits from the session metadata $packageId = $session-&gt;metadata-&gt;package_id; $credits = (int) $session-&gt;metadata-&gt;credits; // Find the package $package = $this-&gt;packageRepository-&gt;find($packageId); if (!$package) { return; } // Add credits to the user's balance $this-&gt;creditService-&gt;addCredits( $user, $credits, 'Purchase of ' . $package-&gt;getName() . ' credit package', CreditTransactionType::PURCHASE, 'session_' . $session-&gt;id, $package-&gt;getPrice(), $package-&gt;getCurrency() ); } } . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#handling-credit-purchase-webhooks",
    
    "relUrl": "/docs/features/pay-per-action/#handling-credit-purchase-webhooks"
  },"25": {
    "doc": "Pay-Per-Action",
    "title": "API Platform Integration",
    "content": "If you’re using API Platform, you can create a custom extension to check if a user has enough credits to access a resource: . &lt;?php namespace App\\ApiPlatform\\Extension; use ApiPlatform\\Doctrine\\Orm\\Extension\\QueryCollectionExtensionInterface; use ApiPlatform\\Doctrine\\Orm\\Extension\\QueryItemExtensionInterface; use ApiPlatform\\Doctrine\\Orm\\Util\\QueryNameGeneratorInterface; use ApiPlatform\\Metadata\\Operation; use App\\Entity\\PremiumResource; use Doctrine\\ORM\\QueryBuilder; use Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Enum\\CreditTransactionType; use Tomedio\\StripeBundle\\Service\\CreditService; class CreditCheckExtension implements QueryCollectionExtensionInterface, QueryItemExtensionInterface { private Security $security; private CreditService $creditService; public function __construct( Security $security, CreditService $creditService ) { $this-&gt;security = $security; $this-&gt;creditService = $creditService; } public function applyToCollection( QueryBuilder $queryBuilder, QueryNameGeneratorInterface $queryNameGenerator, string $resourceClass, Operation $operation = null, array $context = [] ): void { $this-&gt;checkCredits($resourceClass, 'collection'); } public function applyToItem( QueryBuilder $queryBuilder, QueryNameGeneratorInterface $queryNameGenerator, string $resourceClass, array $identifiers, Operation $operation = null, array $context = [] ): void { $this-&gt;checkCredits($resourceClass, 'item', $identifiers['id'] ?? null); } private function checkCredits(string $resourceClass, string $operationType, ?string $itemId = null): void { // Only check credits for premium resources if ($resourceClass !== PremiumResource::class) { return; } $user = $this-&gt;security-&gt;getUser(); if (!$user) { throw new BadRequestException('Authentication required'); } // Define credit costs for different operations $creditCosts = [ 'collection' =&gt; 1, 'item' =&gt; 2, ]; $creditsNeeded = $creditCosts[$operationType] ?? 1; // Use credits $description = 'API access to ' . $resourceClass; if ($itemId) { $description .= ' (ID: ' . $itemId . ')'; } $creditsUsed = $this-&gt;creditService-&gt;useCredits( $user, $creditsNeeded, $description, CreditTransactionType::USAGE, 'api_' . $resourceClass . '_' . $operationType . ($itemId ? '_' . $itemId : '') ); if ($creditsUsed &lt; $creditsNeeded) { throw new BadRequestException( 'Not enough credits. Needed: ' . $creditsNeeded . ', Available: ' . $user-&gt;getCreditsBalance() ); } } } . Register the extension in your services configuration: . # config/services.yaml services: # ... App\\ApiPlatform\\Extension\\CreditCheckExtension: tags: - { name: 'api_platform.doctrine.orm.query_extension.collection' } - { name: 'api_platform.doctrine.orm.query_extension.item' } . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#api-platform-integration",
    
    "relUrl": "/docs/features/pay-per-action/#api-platform-integration"
  },"26": {
    "doc": "Pay-Per-Action",
    "title": "Frontend Integration",
    "content": "Here’s an example of how to integrate the credits system with a React frontend: . import React, { useState, useEffect } from 'react'; import axios from 'axios'; const CreditPackages = () =&gt; { const [packages, setPackages] = useState([]); const [balance, setBalance] = useState(0); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); useEffect(() =&gt; { const fetchData = async () =&gt; { try { const [packagesResponse, balanceResponse] = await Promise.all([ axios.get('/api/credit_packages'), axios.get('/api/credits/balance') ]); setPackages(packagesResponse.data['hydra:member']); setBalance(balanceResponse.data.balance); setLoading(false); } catch (err) { setError('Failed to load data'); setLoading(false); } }; fetchData(); }, []); const handlePurchase = async (packageId) =&gt; { try { const response = await axios.post('/api/credits/checkout', { packageId: packageId }); // Redirect to Stripe Checkout window.location.href = response.data.checkoutUrl; } catch (err) { setError('Failed to create checkout session'); } }; if (loading) return &lt;div&gt;Loading...&lt;/div&gt;; if (error) return &lt;div&gt;{error}&lt;/div&gt;; return ( &lt;div className=\"credit-packages\"&gt; &lt;h2&gt;Your Credit Balance: {balance}&lt;/h2&gt; &lt;h3&gt;Purchase Credits&lt;/h3&gt; &lt;div className=\"packages-container\"&gt; {packages.map(pkg =&gt; ( &lt;div key={pkg.id} className=\"package-card\"&gt; &lt;h4&gt;{pkg.name}&lt;/h4&gt; &lt;p&gt;{pkg.description}&lt;/p&gt; &lt;div className=\"credits\"&gt; {pkg.credits} credits &lt;/div&gt; &lt;div className=\"price\"&gt; ${(pkg.price / 100).toFixed(2)} &lt;/div&gt; &lt;button onClick={() =&gt; handlePurchase(pkg.id)} className=\"purchase-button\" &gt; Purchase &lt;/button&gt; &lt;/div&gt; ))} &lt;/div&gt; &lt;/div&gt; ); }; export default CreditPackages; . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#frontend-integration",
    
    "relUrl": "/docs/features/pay-per-action/#frontend-integration"
  },"27": {
    "doc": "Pay-Per-Action",
    "title": "Best Practices",
    "content": ". | Transaction Logging: Always log credit transactions for auditing and debugging purposes | Error Handling: Implement proper error handling for credit operations | Idempotency: Ensure your webhook handlers are idempotent to prevent duplicate credit additions | Security: Validate that the user has permission to perform credit operations | Monitoring: Monitor credit usage to detect unusual patterns or potential abuse | Notifications: Notify users when their credit balance is low | Refunds: Implement a system for handling refunds if necessary | . ",
    "url": "/stripe-symfony/docs/features/pay-per-action/#best-practices",
    
    "relUrl": "/docs/features/pay-per-action/#best-practices"
  },"28": {
    "doc": "Pay-Per-Action",
    "title": "Pay-Per-Action",
    "content": " ",
    "url": "/stripe-symfony/docs/features/pay-per-action/",
    
    "relUrl": "/docs/features/pay-per-action/"
  },"29": {
    "doc": "Subscription Checkout",
    "title": "Subscription Checkout",
    "content": " ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/",
    
    "relUrl": "/docs/features/subscription-checkout/"
  },"30": {
    "doc": "Subscription Checkout",
    "title": "Table of contents",
    "content": ". | Overview | Creating a Checkout Session | API Platform Integration | Frontend Integration | Handling Checkout Completion | Success and Cancel Pages | Testing the Checkout Flow | Best Practices | . ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#table-of-contents",
    
    "relUrl": "/docs/features/subscription-checkout/#table-of-contents"
  },"31": {
    "doc": "Subscription Checkout",
    "title": "Overview",
    "content": "The Stripe Bundle provides a streamlined way to create subscription checkout sessions for your users. This allows them to select a subscription plan and complete the payment process securely through Stripe Checkout. ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#overview",
    
    "relUrl": "/docs/features/subscription-checkout/#overview"
  },"32": {
    "doc": "Subscription Checkout",
    "title": "Creating a Checkout Session",
    "content": "To create a checkout session for a subscription, you’ll use the SubscriptionService: . &lt;?php namespace App\\Controller; use App\\Repository\\SubscriptionPlanRepository; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Annotation\\Route; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Service\\SubscriptionService; class SubscriptionController extends AbstractController { private Security $security; private SubscriptionService $subscriptionService; private SubscriptionPlanRepository $planRepository; public function __construct( Security $security, SubscriptionService $subscriptionService, SubscriptionPlanRepository $planRepository ) { $this-&gt;security = $security; $this-&gt;subscriptionService = $subscriptionService; $this-&gt;planRepository = $planRepository; } #[Route('/subscription/checkout/{planId}', name: 'subscription_checkout')] public function checkout(string $planId): Response { $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;redirectToRoute('app_login'); } $plan = $this-&gt;planRepository-&gt;find($planId); if (!$plan) { throw $this-&gt;createNotFoundException('Subscription plan not found'); } // Create a checkout session $checkoutUrl = $this-&gt;subscriptionService-&gt;createCheckoutSession($user, $plan); // Redirect to Stripe Checkout return $this-&gt;redirect($checkoutUrl); } } . ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#creating-a-checkout-session",
    
    "relUrl": "/docs/features/subscription-checkout/#creating-a-checkout-session"
  },"33": {
    "doc": "Subscription Checkout",
    "title": "API Platform Integration",
    "content": "If you’re using API Platform, you can create a custom operation for subscription checkout: . &lt;?php namespace App\\Controller; use App\\Repository\\SubscriptionPlanRepository; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpKernel\\Attribute\\AsController; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Service\\SubscriptionService; #[AsController] class CreateSubscriptionController extends AbstractController { private Security $security; private SubscriptionService $subscriptionService; private SubscriptionPlanRepository $planRepository; public function __construct( Security $security, SubscriptionService $subscriptionService, SubscriptionPlanRepository $planRepository ) { $this-&gt;security = $security; $this-&gt;subscriptionService = $subscriptionService; $this-&gt;planRepository = $planRepository; } public function __invoke(Request $request): Response { $data = json_decode($request-&gt;getContent(), true); $planId = $data['planId'] ?? null; if (!$planId) { return $this-&gt;json(['error' =&gt; 'Plan ID is required'], Response::HTTP_BAD_REQUEST); } $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;json(['error' =&gt; 'User not authenticated'], Response::HTTP_UNAUTHORIZED); } $plan = $this-&gt;planRepository-&gt;find($planId); if (!$plan) { return $this-&gt;json(['error' =&gt; 'Plan not found'], Response::HTTP_NOT_FOUND); } // Create a checkout session $checkoutUrl = $this-&gt;subscriptionService-&gt;createCheckoutSession($user, $plan); return $this-&gt;json([ 'checkoutUrl' =&gt; $checkoutUrl ]); } } . Then, in your API resource: . &lt;?php namespace App\\Entity; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Get; use ApiPlatform\\Metadata\\GetCollection; use ApiPlatform\\Metadata\\Post; use App\\Controller\\CreateSubscriptionController; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Contract\\SubscriptionInterface; #[ApiResource( operations: [ new Get(), new GetCollection(), new Post( uriTemplate: '/subscriptions/checkout', controller: CreateSubscriptionController::class, name: 'subscription_checkout', openapiContext: [ 'summary' =&gt; 'Create a subscription checkout session', 'requestBody' =&gt; [ 'content' =&gt; [ 'application/json' =&gt; [ 'schema' =&gt; [ 'type' =&gt; 'object', 'properties' =&gt; [ 'planId' =&gt; [ 'type' =&gt; 'string', 'example' =&gt; 'basic' ] ] ] ] ] ] ] ), ], normalizationContext: ['groups' =&gt; ['subscription:read']], denormalizationContext: ['groups' =&gt; ['subscription:write']] )] #[ORM\\Entity] class Subscription implements SubscriptionInterface { // ... properties and methods } . ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#api-platform-integration",
    
    "relUrl": "/docs/features/subscription-checkout/#api-platform-integration"
  },"34": {
    "doc": "Subscription Checkout",
    "title": "Frontend Integration",
    "content": "Here’s an example of how to integrate the subscription checkout with a React frontend: . import React, { useState, useEffect } from 'react'; import axios from 'axios'; const SubscriptionPlans = () =&gt; { const [plans, setPlans] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); useEffect(() =&gt; { const fetchPlans = async () =&gt; { try { const response = await axios.get('/api/subscription_plans'); setPlans(response.data['hydra:member']); setLoading(false); } catch (err) { setError('Failed to load subscription plans'); setLoading(false); } }; fetchPlans(); }, []); const handleSubscribe = async (planId) =&gt; { try { const response = await axios.post('/api/subscriptions/checkout', { planId: planId }); // Redirect to Stripe Checkout window.location.href = response.data.checkoutUrl; } catch (err) { setError('Failed to create checkout session'); } }; if (loading) return &lt;div&gt;Loading plans...&lt;/div&gt;; if (error) return &lt;div&gt;{error}&lt;/div&gt;; return ( &lt;div className=\"subscription-plans\"&gt; &lt;h2&gt;Choose a Subscription Plan&lt;/h2&gt; &lt;div className=\"plans-container\"&gt; {plans.map(plan =&gt; ( &lt;div key={plan.id} className=\"plan-card\"&gt; &lt;h3&gt;{plan.name}&lt;/h3&gt; &lt;p&gt;{plan.description}&lt;/p&gt; &lt;div className=\"price\"&gt; ${(plan.amount / 100).toFixed(2)} / {plan.interval} &lt;/div&gt; {plan.trialPeriodDays &amp;&amp; ( &lt;div className=\"trial\"&gt; {plan.trialPeriodDays} days free trial &lt;/div&gt; )} &lt;button onClick={() =&gt; handleSubscribe(plan.id)} className=\"subscribe-button\" &gt; Subscribe &lt;/button&gt; &lt;/div&gt; ))} &lt;/div&gt; &lt;/div&gt; ); }; export default SubscriptionPlans; . ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#frontend-integration",
    
    "relUrl": "/docs/features/subscription-checkout/#frontend-integration"
  },"35": {
    "doc": "Subscription Checkout",
    "title": "Handling Checkout Completion",
    "content": "After the user completes the checkout process, Stripe will redirect them to the success URL you configured. You’ll also receive a webhook event (checkout.session.completed) that you should handle to update the subscription status in your database. Here’s an example of handling the webhook event: . &lt;?php namespace App\\EventSubscriber; use App\\Entity\\Subscription; use App\\Repository\\SubscriptionPlanRepository; use App\\Repository\\UserRepository; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Tomedio\\StripeBundle\\Enum\\SubscriptionStatus; use Tomedio\\StripeBundle\\Event\\StripeWebhookEvent; class StripeWebhookSubscriber implements EventSubscriberInterface { private UserRepository $userRepository; private SubscriptionPlanRepository $planRepository; private EntityManagerInterface $entityManager; public function __construct( UserRepository $userRepository, SubscriptionPlanRepository $planRepository, EntityManagerInterface $entityManager ) { $this-&gt;userRepository = $userRepository; $this-&gt;planRepository = $planRepository; $this-&gt;entityManager = $entityManager; } public static function getSubscribedEvents(): array { return [ 'stripe.checkout_session_completed' =&gt; 'onCheckoutSessionCompleted', ]; } public function onCheckoutSessionCompleted(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $session = $stripeEvent-&gt;data-&gt;object; // Get the customer ID from the session $customerId = $session-&gt;customer; // Find the user by Stripe customer ID $user = $this-&gt;userRepository-&gt;findOneByStripeCustomerId($customerId); if (!$user) { return; } // Get the subscription ID from the session $subscriptionId = $session-&gt;subscription; if (!$subscriptionId) { return; } // Get the plan ID from the session metadata $planId = $session-&gt;metadata-&gt;plan_id ?? null; if (!$planId) { return; } // Find the plan $plan = $this-&gt;planRepository-&gt;find($planId); if (!$plan) { return; } // Create a new subscription or update an existing one $subscription = new Subscription(); $subscription-&gt;setUser($user); $subscription-&gt;setPlan($plan); $subscription-&gt;setStripeSubscriptionId($subscriptionId); $subscription-&gt;setStatus(SubscriptionStatus::ACTIVE); $subscription-&gt;setStartDate(new \\DateTime()); // If the plan has a trial period, set the trial end date if ($plan-&gt;getTrialPeriodDays()) { $trialEndDate = new \\DateTime(); $trialEndDate-&gt;modify('+' . $plan-&gt;getTrialPeriodDays() . ' days'); $subscription-&gt;setTrialEndDate($trialEndDate); $subscription-&gt;setStatus(SubscriptionStatus::TRIALING); } // Save the subscription $this-&gt;entityManager-&gt;persist($subscription); // Set the subscription as the user's active subscription $user-&gt;setActiveSubscription($subscription); $this-&gt;entityManager-&gt;persist($user); $this-&gt;entityManager-&gt;flush(); } } . ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#handling-checkout-completion",
    
    "relUrl": "/docs/features/subscription-checkout/#handling-checkout-completion"
  },"36": {
    "doc": "Subscription Checkout",
    "title": "Success and Cancel Pages",
    "content": "You’ll need to create success and cancel pages for users to be redirected to after the checkout process: . &lt;?php namespace App\\Controller; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\Routing\\Annotation\\Route; class SubscriptionController extends AbstractController { // ... other methods #[Route('/subscription/success', name: 'subscription_success')] public function success(): Response { return $this-&gt;render('subscription/success.html.twig'); } #[Route('/subscription/cancel', name: 'subscription_cancel')] public function cancel(): Response { return $this-&gt;render('subscription/cancel.html.twig'); } } . ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#success-and-cancel-pages",
    
    "relUrl": "/docs/features/subscription-checkout/#success-and-cancel-pages"
  },"37": {
    "doc": "Subscription Checkout",
    "title": "Testing the Checkout Flow",
    "content": "To test the checkout flow, you can use Stripe’s test cards: . | For successful payments: 4242 4242 4242 4242 | For failed payments: 4000 0000 0000 0002 | . Make sure to use a future expiration date, any 3-digit CVC, and any 5-digit ZIP code. ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#testing-the-checkout-flow",
    
    "relUrl": "/docs/features/subscription-checkout/#testing-the-checkout-flow"
  },"38": {
    "doc": "Subscription Checkout",
    "title": "Best Practices",
    "content": ". | Metadata: Always include relevant metadata in the checkout session (like the plan ID) to help with webhook processing | Error Handling: Implement proper error handling for API requests and webhook processing | Idempotency: Ensure your webhook handlers are idempotent to prevent duplicate subscriptions | Security: Validate that the user has permission to subscribe to the plan | Logging: Log checkout events for debugging and auditing purposes | . ",
    "url": "/stripe-symfony/docs/features/subscription-checkout/#best-practices",
    
    "relUrl": "/docs/features/subscription-checkout/#best-practices"
  },"39": {
    "doc": "Webhooks",
    "title": "Webhook Handling",
    "content": " ",
    "url": "/stripe-symfony/docs/features/webhooks/#webhook-handling",
    
    "relUrl": "/docs/features/webhooks/#webhook-handling"
  },"40": {
    "doc": "Webhooks",
    "title": "Table of contents",
    "content": ". | Overview | Configuration | Webhook Endpoint | Handling Webhook Events | Important Webhook Events | Testing Webhooks | Best Practices | . ",
    "url": "/stripe-symfony/docs/features/webhooks/#table-of-contents",
    
    "relUrl": "/docs/features/webhooks/#table-of-contents"
  },"41": {
    "doc": "Webhooks",
    "title": "Overview",
    "content": "Webhooks are a crucial part of integrating with Stripe. They allow Stripe to notify your application when events happen in your account, such as successful payments, failed charges, or subscription updates. The Stripe Bundle provides a comprehensive webhook handling system that: . | Validates incoming webhook requests from Stripe | Converts Stripe events into Symfony events | Allows you to handle these events in your application | . ",
    "url": "/stripe-symfony/docs/features/webhooks/#overview",
    
    "relUrl": "/docs/features/webhooks/#overview"
  },"42": {
    "doc": "Webhooks",
    "title": "Configuration",
    "content": "To use webhooks, you need to configure your webhook secret in your Stripe Bundle configuration: . # config/packages/stripe_bundle.yaml stripe_bundle: # ... other configuration webhook_secret: '%env(STRIPE_WEBHOOK_SECRET)%' . You can get your webhook secret from the Stripe Dashboard: . | Go to the Stripe Dashboard | Navigate to Developers &gt; Webhooks | Add a new endpoint with your application’s URL (e.g., https://your-domain.com/stripe/webhook) | Copy the signing secret and add it to your .env file: | . STRIPE_WEBHOOK_SECRET=whsec_... ",
    "url": "/stripe-symfony/docs/features/webhooks/#configuration",
    
    "relUrl": "/docs/features/webhooks/#configuration"
  },"43": {
    "doc": "Webhooks",
    "title": "Webhook Endpoint",
    "content": "The bundle automatically registers a webhook endpoint at /stripe/webhook. You can customize this path in your routes configuration: . # config/routes.yaml stripe_bundle: resource: '@StripeBundle/Controller/' type: annotation prefix: /custom-path # Optional: customize the path prefix . ",
    "url": "/stripe-symfony/docs/features/webhooks/#webhook-endpoint",
    
    "relUrl": "/docs/features/webhooks/#webhook-endpoint"
  },"44": {
    "doc": "Webhooks",
    "title": "Handling Webhook Events",
    "content": "The bundle converts Stripe webhook events into Symfony events with the prefix stripe. followed by the Stripe event name. For example, the Stripe event customer.subscription.created becomes the Symfony event stripe.customer_subscription_created. To handle these events, create an event subscriber: . &lt;?php namespace App\\EventSubscriber; use App\\Repository\\UserRepository; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Tomedio\\StripeBundle\\Event\\StripeWebhookEvent; class StripeWebhookSubscriber implements EventSubscriberInterface { private UserRepository $userRepository; private EntityManagerInterface $entityManager; public function __construct( UserRepository $userRepository, EntityManagerInterface $entityManager ) { $this-&gt;userRepository = $userRepository; $this-&gt;entityManager = $entityManager; } public static function getSubscribedEvents(): array { return [ 'stripe.customer_subscription_created' =&gt; 'onSubscriptionCreated', 'stripe.customer_subscription_updated' =&gt; 'onSubscriptionUpdated', 'stripe.customer_subscription_deleted' =&gt; 'onSubscriptionDeleted', 'stripe.invoice_paid' =&gt; 'onInvoicePaid', 'stripe.checkout_session_completed' =&gt; 'onCheckoutSessionCompleted', ]; } public function onSubscriptionCreated(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $subscription = $stripeEvent-&gt;data-&gt;object; $customerId = $subscription-&gt;customer; $user = $this-&gt;userRepository-&gt;findOneByStripeCustomerId($customerId); if (!$user) { return; } // Handle subscription creation // ... $this-&gt;entityManager-&gt;flush(); } // Implement other event handlers... } . ",
    "url": "/stripe-symfony/docs/features/webhooks/#handling-webhook-events",
    
    "relUrl": "/docs/features/webhooks/#handling-webhook-events"
  },"45": {
    "doc": "Webhooks",
    "title": "Important Webhook Events",
    "content": "Here are some of the most important webhook events you might want to handle: . | Stripe Event | Symfony Event | Description | . | checkout.session.completed | stripe.checkout_session_completed | A checkout session has been completed | . | customer.subscription.created | stripe.customer_subscription_created | A customer subscription has been created | . | customer.subscription.updated | stripe.customer_subscription_updated | A customer subscription has been updated | . | customer.subscription.deleted | stripe.customer_subscription_deleted | A customer subscription has been deleted | . | invoice.paid | stripe.invoice_paid | An invoice has been paid | . | invoice.payment_failed | stripe.invoice_payment_failed | An invoice payment has failed | . ",
    "url": "/stripe-symfony/docs/features/webhooks/#important-webhook-events",
    
    "relUrl": "/docs/features/webhooks/#important-webhook-events"
  },"46": {
    "doc": "Webhooks",
    "title": "Testing Webhooks",
    "content": "During development, you can use the Stripe CLI to test webhooks locally: . | Install the Stripe CLI | Login to your Stripe account: | . stripe login . | Forward webhook events to your local server: | . stripe listen --forward-to http://localhost:8000/stripe/webhook . | Trigger test webhook events: | . stripe trigger checkout.session.completed . ",
    "url": "/stripe-symfony/docs/features/webhooks/#testing-webhooks",
    
    "relUrl": "/docs/features/webhooks/#testing-webhooks"
  },"47": {
    "doc": "Webhooks",
    "title": "Best Practices",
    "content": ". | Idempotency: Ensure your webhook handlers are idempotent, as Stripe may send the same event multiple times | Error Handling: Implement proper error handling in your webhook handlers | Logging: Log webhook events for debugging and auditing purposes | Verification: Always verify the webhook signature to ensure the request is coming from Stripe | Async Processing: For time-consuming operations, consider using a message queue to process webhook events asynchronously | . ",
    "url": "/stripe-symfony/docs/features/webhooks/#best-practices",
    
    "relUrl": "/docs/features/webhooks/#best-practices"
  },"48": {
    "doc": "Webhooks",
    "title": "Webhooks",
    "content": " ",
    "url": "/stripe-symfony/docs/features/webhooks/",
    
    "relUrl": "/docs/features/webhooks/"
  },"49": {
    "doc": "Getting Started",
    "title": "Getting Started with Stripe Bundle",
    "content": "This section will guide you through the process of installing and configuring the Stripe Bundle for your Symfony application. ",
    "url": "/stripe-symfony/docs/getting-started#getting-started-with-stripe-bundle",
    
    "relUrl": "/docs/getting-started#getting-started-with-stripe-bundle"
  },"50": {
    "doc": "Getting Started",
    "title": "What You’ll Learn",
    "content": ". | How to install the Stripe Bundle | How to configure the bundle for your application | How to set up subscription plans | Basic usage examples to get you started quickly | . ",
    "url": "/stripe-symfony/docs/getting-started#what-youll-learn",
    
    "relUrl": "/docs/getting-started#what-youll-learn"
  },"51": {
    "doc": "Getting Started",
    "title": "Prerequisites",
    "content": "Before you begin, make sure you have: . | A Symfony application (version 6.0 or higher) | Doctrine ORM configured | API Platform installed (if you plan to use the API features) | A Stripe account with API keys | . ",
    "url": "/stripe-symfony/docs/getting-started#prerequisites",
    
    "relUrl": "/docs/getting-started#prerequisites"
  },"52": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/stripe-symfony/docs/getting-started",
    
    "relUrl": "/docs/getting-started"
  },"53": {
    "doc": "Installation",
    "title": "Installation",
    "content": " ",
    "url": "/stripe-symfony/docs/getting-started/installation/",
    
    "relUrl": "/docs/getting-started/installation/"
  },"54": {
    "doc": "Installation",
    "title": "Table of contents",
    "content": ". | Requirements | Installation Steps . | Step 1: Configure Symfony Flex (Optional) | Step 2: Install the bundle | Step 3: Register the bundle | Step 4: Add environment variables | Step 5: Customize the configuration (optional) | . | Verifying the Installation | Next Steps | . ",
    "url": "/stripe-symfony/docs/getting-started/installation/#table-of-contents",
    
    "relUrl": "/docs/getting-started/installation/#table-of-contents"
  },"55": {
    "doc": "Installation",
    "title": "Requirements",
    "content": "Before installing the Stripe Bundle, make sure your system meets the following requirements: . | PHP 8.1 or higher | Symfony 6.0 or higher | Doctrine ORM 2.10 or higher | API Platform 3.0 or higher | Stripe PHP SDK 10.0 or higher | . ",
    "url": "/stripe-symfony/docs/getting-started/installation/#requirements",
    
    "relUrl": "/docs/getting-started/installation/#requirements"
  },"56": {
    "doc": "Installation",
    "title": "Installation Steps",
    "content": "Step 1: Configure Symfony Flex (Optional) . This bundle provides custom Symfony Flex recipes to simplify the installation process. To use them, add the following to your application’s composer.json file: . { \"extra\": { \"symfony\": { \"endpoint\": [ \"https://raw.githubusercontent.com/tomedio/flex-recipes/main/index.json\", \"flex://defaults\" ] } } } . Step 2: Install the bundle . Use Composer to install the bundle: . composer require tomedio/stripe-symfony . Step 3: Register the bundle . If you’re using Symfony Flex, the bundle should be automatically registered. If not, add it to your config/bundles.php: . // config/bundles.php return [ // ... Tomedio\\StripeBundle\\StripeBundle::class =&gt; ['all' =&gt; true], ]; . Step 4: Add environment variables . The bundle will automatically create the necessary configuration files during installation. You just need to add the required environment variables to your .env file: . # .env STRIPE_API_KEY=sk_test_... STRIPE_WEBHOOK_SECRET=whsec_... STRIPE_SUCCESS_URL=https://your-domain.com/payment/success STRIPE_CANCEL_URL=https://your-domain.com/payment/cancel . Never commit your Stripe API key to version control. Always use environment variables. Step 5: Customize the configuration (optional) . The bundle creates a default configuration file at config/packages/stripe_bundle.yaml. You can customize it to add subscription plans or change other settings: . # config/packages/stripe_bundle.yaml stripe_bundle: api_key: '%env(STRIPE_API_KEY)%' webhook_secret: '%env(STRIPE_WEBHOOK_SECRET)%' success_url: '%env(STRIPE_SUCCESS_URL)%' cancel_url: '%env(STRIPE_CANCEL_URL)%' subscription_plans: - id: basic name: 'Basic Plan' description: 'Basic features' amount: 999 currency: 'usd' interval: 'month' - id: premium name: 'Premium Plan' description: 'Premium features' amount: 1999 currency: 'usd' interval: 'month' trial_period_days: 14 . ",
    "url": "/stripe-symfony/docs/getting-started/installation/#installation-steps",
    
    "relUrl": "/docs/getting-started/installation/#installation-steps"
  },"57": {
    "doc": "Installation",
    "title": "Verifying the Installation",
    "content": "To verify that the bundle is installed correctly, run the following command: . php bin/console debug:container stripe . You should see several services related to the Stripe Bundle. ",
    "url": "/stripe-symfony/docs/getting-started/installation/#verifying-the-installation",
    
    "relUrl": "/docs/getting-started/installation/#verifying-the-installation"
  },"58": {
    "doc": "Installation",
    "title": "Next Steps",
    "content": "Now that you have installed the Stripe Bundle, you can: . | Configure your subscription plans | Implement the required interfaces | Set up webhook handling | . ",
    "url": "/stripe-symfony/docs/getting-started/installation/#next-steps",
    
    "relUrl": "/docs/getting-started/installation/#next-steps"
  },"59": {
    "doc": "Subscription Plans",
    "title": "Subscription Plans",
    "content": " ",
    "url": "/stripe-symfony/docs/getting-started/subscription-plans/",
    
    "relUrl": "/docs/getting-started/subscription-plans/"
  },"60": {
    "doc": "Subscription Plans",
    "title": "Table of contents",
    "content": ". | Overview | Defining Subscription Plans . | Plan Properties | . | Synchronizing Plans . | Automatic Synchronization | . | Implementing Event Listeners . | Required Events | Example Implementation | . | Next Steps | . ",
    "url": "/stripe-symfony/docs/getting-started/subscription-plans/#table-of-contents",
    
    "relUrl": "/docs/getting-started/subscription-plans/#table-of-contents"
  },"61": {
    "doc": "Subscription Plans",
    "title": "Overview",
    "content": "Subscription plans are a core concept in the Stripe Bundle. They define the pricing structure and billing intervals for your SaaS application’s subscription offerings. The bundle provides a way to define these plans in your Symfony configuration and synchronize them with both your database and Stripe. ",
    "url": "/stripe-symfony/docs/getting-started/subscription-plans/#overview",
    
    "relUrl": "/docs/getting-started/subscription-plans/#overview"
  },"62": {
    "doc": "Subscription Plans",
    "title": "Defining Subscription Plans",
    "content": "Subscription plans are defined in your Symfony configuration file: . # config/packages/stripe_bundle.yaml stripe_bundle: # ... other configuration subscription_plans: - id: basic name: 'Basic Plan' description: 'Basic features' amount: 999 # Amount in cents currency: 'usd' interval: 'month' - id: premium name: 'Premium Plan' description: 'Premium features' amount: 1999 # Amount in cents currency: 'usd' interval: 'month' trial_period_days: 14 - id: enterprise name: 'Enterprise Plan' description: 'All features' amount: 4999 # Amount in cents currency: 'usd' interval: 'month' trial_period_days: 30 . Plan Properties . | Property | Type | Description | Required | . | id | string | Unique identifier for the plan | Yes | . | name | string | Display name for the plan | Yes | . | description | string | Description of what the plan offers | No | . | amount | integer | Price in cents (or smallest currency unit) | Yes | . | currency | string | Three-letter ISO currency code | Yes | . | interval | string | Billing interval (day, week, month, or year) | Yes | . | trial_period_days | integer | Number of trial days | No | . ",
    "url": "/stripe-symfony/docs/getting-started/subscription-plans/#defining-subscription-plans",
    
    "relUrl": "/docs/getting-started/subscription-plans/#defining-subscription-plans"
  },"63": {
    "doc": "Subscription Plans",
    "title": "Synchronizing Plans",
    "content": "The bundle includes a command to synchronize your subscription plans with both your database and Stripe: . php bin/console stripe:sync-plans . This command handles all synchronization cases: . | New plans in configuration: Creates them in your database and syncs them to Stripe | Updated plans in configuration: Updates them in your database and syncs changes to Stripe | Removed plans from configuration: Checks if they can be safely removed (no active subscriptions), then deactivates them in Stripe and marks them for deletion in your database | . Automatic Synchronization . You can set up a cron job to run the synchronization command periodically: . # Run every day at midnight 0 0 * * * /path/to/your/project/bin/console stripe:sync-plans . ",
    "url": "/stripe-symfony/docs/getting-started/subscription-plans/#synchronizing-plans",
    
    "relUrl": "/docs/getting-started/subscription-plans/#synchronizing-plans"
  },"64": {
    "doc": "Subscription Plans",
    "title": "Implementing Event Listeners",
    "content": "To fully integrate the subscription plan synchronization, you need to implement event listeners for the following events: . Required Events . | Event | Purpose | . | stripe.plan.list | Return all subscription plans from the database | . | stripe.plan.load | Load a plan from the database or create a new one if it doesn’t exist | . | stripe.plan.update | Update a plan in the database | . | stripe.plan.delete | Check if a plan can be safely deleted and mark it for deletion if possible | . Example Implementation . See the Implementing Event Listeners page for a detailed example of how to implement these event listeners. ",
    "url": "/stripe-symfony/docs/getting-started/subscription-plans/#implementing-event-listeners",
    
    "relUrl": "/docs/getting-started/subscription-plans/#implementing-event-listeners"
  },"65": {
    "doc": "Subscription Plans",
    "title": "Next Steps",
    "content": "Now that you understand how to configure subscription plans, you can: . | Implement the required interfaces | Set up webhook handling | Create a subscription checkout flow | . ",
    "url": "/stripe-symfony/docs/getting-started/subscription-plans/#next-steps",
    
    "relUrl": "/docs/getting-started/subscription-plans/#next-steps"
  },"66": {
    "doc": "API Platform Integration",
    "title": "API Platform Integration",
    "content": " ",
    "url": "/stripe-symfony/docs/integration/api-platform/",
    
    "relUrl": "/docs/integration/api-platform/"
  },"67": {
    "doc": "API Platform Integration",
    "title": "Table of contents",
    "content": ". | Overview | Exposing Entities as API Resources . | Subscription Plans | Subscriptions | Invoices | Credit Packages | . | Custom Controllers . | Subscription Checkout Controller | Subscription Cancel Controller | Credit Checkout Controller | . | API Platform Extensions . | Credit Check Extension | Subscription Check Extension | . | API Platform Event Subscribers . | User Creation Subscriber | . | OpenAPI Documentation | Frontend Integration | . ",
    "url": "/stripe-symfony/docs/integration/api-platform/#table-of-contents",
    
    "relUrl": "/docs/integration/api-platform/#table-of-contents"
  },"68": {
    "doc": "API Platform Integration",
    "title": "Overview",
    "content": "The Stripe Bundle is designed to work seamlessly with API Platform, allowing you to expose your Stripe-related entities as API resources and leverage API Platform’s features for building RESTful APIs. This page covers how to integrate the Stripe Bundle with API Platform in your Symfony application. ",
    "url": "/stripe-symfony/docs/integration/api-platform/#overview",
    
    "relUrl": "/docs/integration/api-platform/#overview"
  },"69": {
    "doc": "API Platform Integration",
    "title": "Exposing Entities as API Resources",
    "content": "Subscription Plans . To expose your subscription plans as an API resource: . &lt;?php namespace App\\Entity; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Get; use ApiPlatform\\Metadata\\GetCollection; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Serializer\\Annotation\\Groups; use Tomedio\\StripeBundle\\Contract\\SubscriptionPlanInterface; use Tomedio\\StripeBundle\\Enum\\BillingInterval; use Tomedio\\StripeBundle\\Enum\\Currency; #[ApiResource( operations: [ new Get( normalizationContext: ['groups' =&gt; ['plan:read', 'plan:item:read']] ), new GetCollection( normalizationContext: ['groups' =&gt; ['plan:read']] ), ], normalizationContext: ['groups' =&gt; ['plan:read']], denormalizationContext: ['groups' =&gt; ['plan:write']] )] #[ORM\\Entity] class SubscriptionPlan implements SubscriptionPlanInterface { #[ORM\\Id] #[ORM\\Column(type: 'string', length: 255)] #[Groups(['plan:read'])] private string $id; #[ORM\\Column(type: 'string', length: 255)] #[Groups(['plan:read'])] private string $name; #[ORM\\Column(type: 'text', nullable: true)] #[Groups(['plan:read'])] private ?string $description = null; #[ORM\\Column(type: 'integer')] #[Groups(['plan:read'])] private int $amount; #[ORM\\Column(type: 'string', length: 3, enumType: Currency::class)] #[Groups(['plan:read'])] private Currency $currency; #[ORM\\Column(type: 'string', length: 10, enumType: BillingInterval::class)] #[Groups(['plan:read'])] private BillingInterval $interval; #[ORM\\Column(type: 'integer', nullable: true)] #[Groups(['plan:read'])] private ?int $trialPeriodDays = null; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripeProductId = null; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripePriceId = null; // Implement getters and setters // ... } . Subscriptions . To expose your subscriptions as an API resource: . &lt;?php namespace App\\Entity; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Get; use ApiPlatform\\Metadata\\GetCollection; use ApiPlatform\\Metadata\\Post; use App\\Controller\\CreateSubscriptionController; use App\\Controller\\CancelSubscriptionController; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Serializer\\Annotation\\Groups; use Tomedio\\StripeBundle\\Contract\\SubscriptionInterface; use Tomedio\\StripeBundle\\Contract\\SubscriptionPlanInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; use Tomedio\\StripeBundle\\Enum\\SubscriptionStatus; #[ApiResource( operations: [ new Get( normalizationContext: ['groups' =&gt; ['subscription:read', 'subscription:item:read']] ), new GetCollection( normalizationContext: ['groups' =&gt; ['subscription:read']] ), new Post( uriTemplate: '/subscriptions/checkout', controller: CreateSubscriptionController::class, name: 'subscription_checkout', openapiContext: [ 'summary' =&gt; 'Create a subscription checkout session', 'requestBody' =&gt; [ 'content' =&gt; [ 'application/json' =&gt; [ 'schema' =&gt; [ 'type' =&gt; 'object', 'properties' =&gt; [ 'planId' =&gt; [ 'type' =&gt; 'string', 'example' =&gt; 'basic' ] ] ] ] ] ] ] ), new Post( uriTemplate: '/subscriptions/{id}/cancel', controller: CancelSubscriptionController::class, name: 'subscription_cancel', openapiContext: [ 'summary' =&gt; 'Cancel a subscription' ] ), ], normalizationContext: ['groups' =&gt; ['subscription:read']], denormalizationContext: ['groups' =&gt; ['subscription:write']] )] #[ORM\\Entity] class Subscription implements SubscriptionInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] #[Groups(['subscription:read'])] private ?int $id = null; #[ORM\\ManyToOne(targetEntity: User::class)] #[ORM\\JoinColumn(nullable: false)] #[Groups(['subscription:read'])] private StripeUserInterface $user; #[ORM\\ManyToOne(targetEntity: SubscriptionPlan::class)] #[ORM\\JoinColumn(nullable: false)] #[Groups(['subscription:read'])] private SubscriptionPlanInterface $plan; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripeSubscriptionId = null; #[ORM\\Column(type: 'string', length: 20, enumType: SubscriptionStatus::class)] #[Groups(['subscription:read'])] private SubscriptionStatus $status; #[ORM\\Column(type: 'datetime', nullable: true)] #[Groups(['subscription:read'])] private ?\\DateTimeInterface $startDate = null; #[ORM\\Column(type: 'datetime', nullable: true)] #[Groups(['subscription:read'])] private ?\\DateTimeInterface $endDate = null; #[ORM\\Column(type: 'datetime', nullable: true)] #[Groups(['subscription:read'])] private ?\\DateTimeInterface $trialEndDate = null; // Implement getters and setters // ... } . Invoices . To expose your invoices as an API resource: . &lt;?php namespace App\\Entity; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Get; use ApiPlatform\\Metadata\\GetCollection; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Serializer\\Annotation\\Groups; use Tomedio\\StripeBundle\\Contract\\StripeInvoiceInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; use Tomedio\\StripeBundle\\Contract\\SubscriptionInterface; use Tomedio\\StripeBundle\\Enum\\Currency; use Tomedio\\StripeBundle\\Enum\\InvoiceStatus; #[ApiResource( operations: [ new Get( normalizationContext: ['groups' =&gt; ['invoice:read', 'invoice:item:read']] ), new GetCollection( normalizationContext: ['groups' =&gt; ['invoice:read']] ), ], normalizationContext: ['groups' =&gt; ['invoice:read']], denormalizationContext: ['groups' =&gt; ['invoice:write']] )] #[ORM\\Entity] class Invoice implements StripeInvoiceInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] #[Groups(['invoice:read'])] private ?int $id = null; #[ORM\\ManyToOne(targetEntity: User::class)] #[ORM\\JoinColumn(nullable: false)] #[Groups(['invoice:read'])] private StripeUserInterface $user; #[ORM\\ManyToOne(targetEntity: Subscription::class)] #[Groups(['invoice:read'])] private ?SubscriptionInterface $subscription = null; #[ORM\\Column(type: 'string', length: 255)] private string $stripeInvoiceId; #[ORM\\Column(type: 'integer')] #[Groups(['invoice:read'])] private int $amount; #[ORM\\Column(type: 'string', length: 3, enumType: Currency::class)] #[Groups(['invoice:read'])] private Currency $currency; #[ORM\\Column(type: 'string', length: 20, enumType: InvoiceStatus::class)] #[Groups(['invoice:read'])] private InvoiceStatus $status; #[ORM\\Column(type: 'datetime')] #[Groups(['invoice:read'])] private \\DateTimeInterface $invoiceDate; #[ORM\\Column(type: 'datetime', nullable: true)] #[Groups(['invoice:read'])] private ?\\DateTimeInterface $dueDate = null; #[ORM\\Column(type: 'datetime', nullable: true)] #[Groups(['invoice:read'])] private ?\\DateTimeInterface $paidDate = null; // Implement getters and setters // ... } . Credit Packages . If you’re using the credits system, you can expose your credit packages as an API resource: . &lt;?php namespace App\\Entity; use ApiPlatform\\Metadata\\ApiResource; use ApiPlatform\\Metadata\\Get; use ApiPlatform\\Metadata\\GetCollection; use ApiPlatform\\Metadata\\Post; use App\\Controller\\CreateCreditCheckoutController; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Serializer\\Annotation\\Groups; use Tomedio\\StripeBundle\\Enum\\Currency; #[ApiResource( operations: [ new Get( normalizationContext: ['groups' =&gt; ['credit_package:read', 'credit_package:item:read']] ), new GetCollection( normalizationContext: ['groups' =&gt; ['credit_package:read']] ), new Post( uriTemplate: '/credit_packages/checkout', controller: CreateCreditCheckoutController::class, name: 'credit_package_checkout', openapiContext: [ 'summary' =&gt; 'Create a credit package checkout session', 'requestBody' =&gt; [ 'content' =&gt; [ 'application/json' =&gt; [ 'schema' =&gt; [ 'type' =&gt; 'object', 'properties' =&gt; [ 'packageId' =&gt; [ 'type' =&gt; 'integer', 'example' =&gt; 1 ] ] ] ] ] ] ] ), ], normalizationContext: ['groups' =&gt; ['credit_package:read']], denormalizationContext: ['groups' =&gt; ['credit_package:write']] )] #[ORM\\Entity] class CreditPackage { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] #[Groups(['credit_package:read'])] private ?int $id = null; #[ORM\\Column(type: 'string', length: 255)] #[Groups(['credit_package:read'])] private string $name; #[ORM\\Column(type: 'text', nullable: true)] #[Groups(['credit_package:read'])] private ?string $description = null; #[ORM\\Column(type: 'integer')] #[Groups(['credit_package:read'])] private int $credits; #[ORM\\Column(type: 'integer')] #[Groups(['credit_package:read'])] private int $price; #[ORM\\Column(type: 'string', length: 3, enumType: Currency::class)] #[Groups(['credit_package:read'])] private Currency $currency; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripeProductId = null; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripePriceId = null; // Implement getters and setters // ... } . ",
    "url": "/stripe-symfony/docs/integration/api-platform/#exposing-entities-as-api-resources",
    
    "relUrl": "/docs/integration/api-platform/#exposing-entities-as-api-resources"
  },"70": {
    "doc": "API Platform Integration",
    "title": "Custom Controllers",
    "content": "Subscription Checkout Controller . Create a controller for handling subscription checkout: . &lt;?php namespace App\\Controller; use App\\Repository\\SubscriptionPlanRepository; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpKernel\\Attribute\\AsController; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Service\\SubscriptionService; #[AsController] class CreateSubscriptionController extends AbstractController { private Security $security; private SubscriptionService $subscriptionService; private SubscriptionPlanRepository $planRepository; public function __construct( Security $security, SubscriptionService $subscriptionService, SubscriptionPlanRepository $planRepository ) { $this-&gt;security = $security; $this-&gt;subscriptionService = $subscriptionService; $this-&gt;planRepository = $planRepository; } public function __invoke(Request $request): Response { $data = json_decode($request-&gt;getContent(), true); $planId = $data['planId'] ?? null; if (!$planId) { return $this-&gt;json(['error' =&gt; 'Plan ID is required'], Response::HTTP_BAD_REQUEST); } $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;json(['error' =&gt; 'User not authenticated'], Response::HTTP_UNAUTHORIZED); } $plan = $this-&gt;planRepository-&gt;find($planId); if (!$plan) { return $this-&gt;json(['error' =&gt; 'Plan not found'], Response::HTTP_NOT_FOUND); } // Create a checkout session $checkoutUrl = $this-&gt;subscriptionService-&gt;createCheckoutSession($user, $plan); return $this-&gt;json([ 'checkoutUrl' =&gt; $checkoutUrl ]); } } . Subscription Cancel Controller . Create a controller for handling subscription cancellation: . &lt;?php namespace App\\Controller; use App\\Repository\\SubscriptionRepository; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpKernel\\Attribute\\AsController; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Service\\SubscriptionService; #[AsController] class CancelSubscriptionController extends AbstractController { private Security $security; private SubscriptionService $subscriptionService; private SubscriptionRepository $subscriptionRepository; public function __construct( Security $security, SubscriptionService $subscriptionService, SubscriptionRepository $subscriptionRepository ) { $this-&gt;security = $security; $this-&gt;subscriptionService = $subscriptionService; $this-&gt;subscriptionRepository = $subscriptionRepository; } public function __invoke(Request $request, int $id): Response { $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;json(['error' =&gt; 'User not authenticated'], Response::HTTP_UNAUTHORIZED); } $subscription = $this-&gt;subscriptionRepository-&gt;find($id); if (!$subscription) { return $this-&gt;json(['error' =&gt; 'Subscription not found'], Response::HTTP_NOT_FOUND); } // Check if the subscription belongs to the user if ($subscription-&gt;getUser()-&gt;getId() !== $user-&gt;getId()) { return $this-&gt;json(['error' =&gt; 'Unauthorized'], Response::HTTP_FORBIDDEN); } // Cancel the subscription $this-&gt;subscriptionService-&gt;cancelSubscription($subscription); return $this-&gt;json([ 'message' =&gt; 'Subscription cancelled successfully' ]); } } . Credit Checkout Controller . Create a controller for handling credit package checkout: . &lt;?php namespace App\\Controller; use App\\Repository\\CreditPackageRepository; use Symfony\\Bundle\\FrameworkBundle\\Controller\\AbstractController; use Symfony\\Component\\HttpFoundation\\Request; use Symfony\\Component\\HttpFoundation\\Response; use Symfony\\Component\\HttpKernel\\Attribute\\AsController; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Service\\StripeClient; #[AsController] class CreateCreditCheckoutController extends AbstractController { private Security $security; private StripeClient $stripeClient; private CreditPackageRepository $packageRepository; private string $successUrl; private string $cancelUrl; public function __construct( Security $security, StripeClient $stripeClient, CreditPackageRepository $packageRepository, string $successUrl, string $cancelUrl ) { $this-&gt;security = $security; $this-&gt;stripeClient = $stripeClient; $this-&gt;packageRepository = $packageRepository; $this-&gt;successUrl = $successUrl; $this-&gt;cancelUrl = $cancelUrl; } public function __invoke(Request $request): Response { $data = json_decode($request-&gt;getContent(), true); $packageId = $data['packageId'] ?? null; if (!$packageId) { return $this-&gt;json(['error' =&gt; 'Package ID is required'], Response::HTTP_BAD_REQUEST); } $user = $this-&gt;security-&gt;getUser(); if (!$user) { return $this-&gt;json(['error' =&gt; 'User not authenticated'], Response::HTTP_UNAUTHORIZED); } $package = $this-&gt;packageRepository-&gt;find($packageId); if (!$package) { return $this-&gt;json(['error' =&gt; 'Credit package not found'], Response::HTTP_NOT_FOUND); } // Ensure the user has a Stripe customer ID if (!$user-&gt;getStripeCustomerId()) { $customer = $this-&gt;stripeClient-&gt;createCustomer([ 'email' =&gt; $user-&gt;getEmail(), 'name' =&gt; $user-&gt;getName(), ]); $user-&gt;setStripeCustomerId($customer-&gt;id); // Save the user } // Create a Stripe checkout session $session = $this-&gt;stripeClient-&gt;createCheckoutSession([ 'customer' =&gt; $user-&gt;getStripeCustomerId(), 'payment_method_types' =&gt; ['card'], 'line_items' =&gt; [[ 'price_data' =&gt; [ 'currency' =&gt; strtolower($package-&gt;getCurrency()-&gt;value), 'product_data' =&gt; [ 'name' =&gt; $package-&gt;getName(), 'description' =&gt; $package-&gt;getDescription(), ], 'unit_amount' =&gt; $package-&gt;getPrice(), ], 'quantity' =&gt; 1, ]], 'mode' =&gt; 'payment', 'success_url' =&gt; $this-&gt;successUrl . '?session_id={CHECKOUT_SESSION_ID}', 'cancel_url' =&gt; $this-&gt;cancelUrl, 'metadata' =&gt; [ 'package_id' =&gt; $package-&gt;getId(), 'credits' =&gt; $package-&gt;getCredits(), ], ]); return $this-&gt;json([ 'checkoutUrl' =&gt; $session-&gt;url ]); } } . ",
    "url": "/stripe-symfony/docs/integration/api-platform/#custom-controllers",
    
    "relUrl": "/docs/integration/api-platform/#custom-controllers"
  },"71": {
    "doc": "API Platform Integration",
    "title": "API Platform Extensions",
    "content": "Credit Check Extension . Create an extension to check if a user has enough credits to access a resource: . &lt;?php namespace App\\ApiPlatform\\Extension; use ApiPlatform\\Doctrine\\Orm\\Extension\\QueryCollectionExtensionInterface; use ApiPlatform\\Doctrine\\Orm\\Extension\\QueryItemExtensionInterface; use ApiPlatform\\Doctrine\\Orm\\Util\\QueryNameGeneratorInterface; use ApiPlatform\\Metadata\\Operation; use App\\Entity\\PremiumResource; use Doctrine\\ORM\\QueryBuilder; use Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Enum\\CreditTransactionType; use Tomedio\\StripeBundle\\Service\\CreditService; class CreditCheckExtension implements QueryCollectionExtensionInterface, QueryItemExtensionInterface { private Security $security; private CreditService $creditService; public function __construct( Security $security, CreditService $creditService ) { $this-&gt;security = $security; $this-&gt;creditService = $creditService; } public function applyToCollection( QueryBuilder $queryBuilder, QueryNameGeneratorInterface $queryNameGenerator, string $resourceClass, Operation $operation = null, array $context = [] ): void { $this-&gt;checkCredits($resourceClass, 'collection'); } public function applyToItem( QueryBuilder $queryBuilder, QueryNameGeneratorInterface $queryNameGenerator, string $resourceClass, array $identifiers, Operation $operation = null, array $context = [] ): void { $this-&gt;checkCredits($resourceClass, 'item', $identifiers['id'] ?? null); } private function checkCredits(string $resourceClass, string $operationType, ?string $itemId = null): void { // Only check credits for premium resources if ($resourceClass !== PremiumResource::class) { return; } $user = $this-&gt;security-&gt;getUser(); if (!$user) { throw new BadRequestException('Authentication required'); } // Define credit costs for different operations $creditCosts = [ 'collection' =&gt; 1, 'item' =&gt; 2, ]; $creditsNeeded = $creditCosts[$operationType] ?? 1; // Use credits $description = 'API access to ' . $resourceClass; if ($itemId) { $description .= ' (ID: ' . $itemId . ')'; } $creditsUsed = $this-&gt;creditService-&gt;useCredits( $user, $creditsNeeded, $description, CreditTransactionType::USAGE, 'api_' . $resourceClass . '_' . $operationType . ($itemId ? '_' . $itemId : '') ); if ($creditsUsed &lt; $creditsNeeded) { throw new BadRequestException( 'Not enough credits. Needed: ' . $creditsNeeded . ', Available: ' . $user-&gt;getCreditsBalance() ); } } } . Register the extension in your services configuration: . # config/services.yaml services: # ... App\\ApiPlatform\\Extension\\CreditCheckExtension: tags: - { name: 'api_platform.doctrine.orm.query_extension.collection' } - { name: 'api_platform.doctrine.orm.query_extension.item' } . Subscription Check Extension . Create an extension to check if a user has an active subscription to access a resource: . &lt;?php namespace App\\ApiPlatform\\Extension; use ApiPlatform\\Doctrine\\Orm\\Extension\\QueryCollectionExtensionInterface; use ApiPlatform\\Doctrine\\Orm\\Extension\\QueryItemExtensionInterface; use ApiPlatform\\Doctrine\\Orm\\Util\\QueryNameGeneratorInterface; use ApiPlatform\\Metadata\\Operation; use App\\Entity\\SubscriptionProtectedResource; use Doctrine\\ORM\\QueryBuilder; use Symfony\\Component\\HttpFoundation\\Exception\\BadRequestException; use Symfony\\Component\\Security\\Core\\Security; use Tomedio\\StripeBundle\\Enum\\SubscriptionStatus; class SubscriptionCheckExtension implements QueryCollectionExtensionInterface, QueryItemExtensionInterface { private Security $security; public function __construct(Security $security) { $this-&gt;security = $security; } public function applyToCollection( QueryBuilder $queryBuilder, QueryNameGeneratorInterface $queryNameGenerator, string $resourceClass, Operation $operation = null, array $context = [] ): void { $this-&gt;checkSubscription($resourceClass); } public function applyToItem( QueryBuilder $queryBuilder, QueryNameGeneratorInterface $queryNameGenerator, string $resourceClass, array $identifiers, Operation $operation = null, array $context = [] ): void { $this-&gt;checkSubscription($resourceClass); } private function checkSubscription(string $resourceClass): void { // Only check subscription for protected resources if ($resourceClass !== SubscriptionProtectedResource::class) { return; } $user = $this-&gt;security-&gt;getUser(); if (!$user) { throw new BadRequestException('Authentication required'); } // Check if the user has an active subscription $subscription = $user-&gt;getActiveSubscription(); if (!$subscription) { throw new BadRequestException('Active subscription required'); } // Check if the subscription is active or in trial $status = $subscription-&gt;getStatus(); if ($status !== SubscriptionStatus::ACTIVE &amp;&amp; $status !== SubscriptionStatus::TRIALING) { throw new BadRequestException('Active subscription required'); } } } . Register the extension in your services configuration: . # config/services.yaml services: # ... App\\ApiPlatform\\Extension\\SubscriptionCheckExtension: tags: - { name: 'api_platform.doctrine.orm.query_extension.collection' } - { name: 'api_platform.doctrine.orm.query_extension.item' } . ",
    "url": "/stripe-symfony/docs/integration/api-platform/#api-platform-extensions",
    
    "relUrl": "/docs/integration/api-platform/#api-platform-extensions"
  },"72": {
    "doc": "API Platform Integration",
    "title": "API Platform Event Subscribers",
    "content": "User Creation Subscriber . Create a subscriber to automatically create a Stripe customer when a user is created: . &lt;?php namespace App\\EventSubscriber; use ApiPlatform\\Symfony\\EventListener\\EventPriorities; use App\\Entity\\User; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\HttpKernel\\Event\\ViewEvent; use Symfony\\Component\\HttpKernel\\KernelEvents; use Tomedio\\StripeBundle\\Service\\CustomerService; class ApiUserCreationSubscriber implements EventSubscriberInterface { private CustomerService $customerService; public function __construct(CustomerService $customerService) { $this-&gt;customerService = $customerService; } public static function getSubscribedEvents(): array { return [ KernelEvents::VIEW =&gt; ['onUserCreated', EventPriorities::POST_WRITE], ]; } public function onUserCreated(ViewEvent $event): void { $user = $event-&gt;getControllerResult(); $method = $event-&gt;getRequest()-&gt;getMethod(); // Only process POST requests for User entities if (!$user instanceof User || $method !== 'POST') { return; } // Create a Stripe customer for the new user if (!$user-&gt;getStripeCustomerId()) { $this-&gt;customerService-&gt;getOrCreateCustomer($user); } } } . ",
    "url": "/stripe-symfony/docs/integration/api-platform/#api-platform-event-subscribers",
    
    "relUrl": "/docs/integration/api-platform/#api-platform-event-subscribers"
  },"73": {
    "doc": "API Platform Integration",
    "title": "OpenAPI Documentation",
    "content": "API Platform automatically generates OpenAPI documentation for your API. You can customize the documentation for your Stripe-related endpoints: . #[ApiResource( operations: [ new Post( uriTemplate: '/subscriptions/checkout', controller: CreateSubscriptionController::class, name: 'subscription_checkout', openapiContext: [ 'summary' =&gt; 'Create a subscription checkout session', 'description' =&gt; 'Creates a Stripe Checkout session for subscribing to a plan', 'requestBody' =&gt; [ 'content' =&gt; [ 'application/json' =&gt; [ 'schema' =&gt; [ 'type' =&gt; 'object', 'properties' =&gt; [ 'planId' =&gt; [ 'type' =&gt; 'string', 'example' =&gt; 'basic', 'description' =&gt; 'The ID of the subscription plan' ] ], 'required' =&gt; ['planId'] ] ] ] ], 'responses' =&gt; [ '200' =&gt; [ 'description' =&gt; 'Checkout session created', 'content' =&gt; [ 'application/json' =&gt; [ 'schema' =&gt; [ 'type' =&gt; 'object', 'properties' =&gt; [ 'checkoutUrl' =&gt; [ 'type' =&gt; 'string', 'format' =&gt; 'uri', 'description' =&gt; 'URL to redirect the user to for checkout' ] ] ] ] ] ], '400' =&gt; [ 'description' =&gt; 'Invalid input' ], '401' =&gt; [ 'description' =&gt; 'Unauthorized' ], '404' =&gt; [ 'description' =&gt; 'Plan not found' ] ] ] ), ], )] . ",
    "url": "/stripe-symfony/docs/integration/api-platform/#openapi-documentation",
    
    "relUrl": "/docs/integration/api-platform/#openapi-documentation"
  },"74": {
    "doc": "API Platform Integration",
    "title": "Frontend Integration",
    "content": "Here’s an example of how to integrate the API with a React frontend: . ```jsx import React, { useState, useEffect } from ‘react’; import axios from ‘axios’; . const SubscriptionPlans = () =&gt; { const [plans, setPlans] = useState([]); const [loading, setLoading] = useState(true); const [error, setError] = useState(null); . useEffect(() =&gt; { const fetchPlans = async () =&gt; { try { const response = await axios.get(‘/api/subscription_plans’); setPlans(response.data[‘hydra:member’]); setLoading(false); } catch (err) { setError(‘Failed to load subscription plans’); setLoading(false); } }; . fetchPlans(); }, []); . const handleSubscribe = async (planId) =&gt; { try { const response = await axios.post(‘/api/subscriptions/checkout’, { . ",
    "url": "/stripe-symfony/docs/integration/api-platform/#frontend-integration",
    
    "relUrl": "/docs/integration/api-platform/#frontend-integration"
  },"75": {
    "doc": "Event Listeners",
    "title": "Event Listeners",
    "content": " ",
    "url": "/stripe-symfony/docs/integration/event-listeners/",
    
    "relUrl": "/docs/integration/event-listeners/"
  },"76": {
    "doc": "Event Listeners",
    "title": "Table of contents",
    "content": ". | Overview | Subscription Plan Events . | 1. Create an Event Subscriber | 2. Register the Event Subscriber | . | Webhook Events . | 1. Create a Webhook Event Subscriber | 2. Register the Webhook Event Subscriber | . | Credit Events . | 1. Create a Credit Event Subscriber | 2. Register the Credit Event Subscriber | . | API Platform Events . | 1. Create an API Platform Event Subscriber | 2. Register the API Platform Event Subscriber | . | Best Practices | . ",
    "url": "/stripe-symfony/docs/integration/event-listeners/#table-of-contents",
    
    "relUrl": "/docs/integration/event-listeners/#table-of-contents"
  },"77": {
    "doc": "Event Listeners",
    "title": "Overview",
    "content": "The Stripe Bundle uses Symfony’s event system to communicate between different components and to allow your application to react to various events. This approach provides a clean separation of concerns and makes the bundle highly extensible. This page covers how to implement event listeners for the key events in your application. For a comprehensive reference of all events dispatched by the bundle, see the Events page. ",
    "url": "/stripe-symfony/docs/integration/event-listeners/#overview",
    
    "relUrl": "/docs/integration/event-listeners/#overview"
  },"78": {
    "doc": "Event Listeners",
    "title": "Subscription Plan Events",
    "content": "These events are dispatched during the subscription plan synchronization process. 1. Create an Event Subscriber . &lt;?php namespace App\\EventSubscriber; use App\\Entity\\SubscriptionPlan; use App\\Repository\\SubscriptionPlanRepository; use App\\Repository\\SubscriptionRepository; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Tomedio\\StripeBundle\\Event\\SubscriptionPlanCreateEvent; use Tomedio\\StripeBundle\\Event\\SubscriptionPlanDeleteEvent; use Tomedio\\StripeBundle\\Event\\SubscriptionPlanListEvent; use Tomedio\\StripeBundle\\Event\\SubscriptionPlanLoadEvent; use Tomedio\\StripeBundle\\Event\\SubscriptionPlanUpdateEvent; use Tomedio\\StripeBundle\\Model\\SubscriptionPlanConfig; class SubscriptionPlanEventSubscriber implements EventSubscriberInterface { private EntityManagerInterface $entityManager; private SubscriptionPlanRepository $planRepository; private SubscriptionRepository $subscriptionRepository; public function __construct( EntityManagerInterface $entityManager, SubscriptionPlanRepository $planRepository, SubscriptionRepository $subscriptionRepository ) { $this-&gt;entityManager = $entityManager; $this-&gt;planRepository = $planRepository; $this-&gt;subscriptionRepository = $subscriptionRepository; } public static function getSubscribedEvents(): array { return [ 'stripe.plan.list' =&gt; 'onPlanList', 'stripe.plan.load' =&gt; 'onPlanLoad', 'stripe.plan.create' =&gt; 'onPlanCreate', 'stripe.plan.update' =&gt; 'onPlanUpdate', 'stripe.plan.delete' =&gt; 'onPlanDelete', ]; } /** * Return all subscription plans from the database. */ public function onPlanList(SubscriptionPlanListEvent $event): void { $plans = $this-&gt;planRepository-&gt;findAll(); $event-&gt;setPlans($plans); } /** * Load a plan from the database or create a new one if it doesn't exist. */ public function onPlanLoad(SubscriptionPlanLoadEvent $event): void { $planId = $event-&gt;getPlanId(); $config = $event-&gt;getConfig(); // Try to find the plan in the database $plan = $this-&gt;planRepository-&gt;find($planId); // If the plan doesn't exist, create a new one if (!$plan) { $plan = $this-&gt;createPlanFromConfig($config); $this-&gt;entityManager-&gt;persist($plan); $this-&gt;entityManager-&gt;flush(); } $event-&gt;setPlan($plan); } /** * Create a new plan in the database. */ public function onPlanCreate(SubscriptionPlanCreateEvent $event): void { $plan = $event-&gt;getPlan(); // Save the plan to the database $this-&gt;entityManager-&gt;persist($plan); $this-&gt;entityManager-&gt;flush(); } /** * Update a plan in the database. */ public function onPlanUpdate(SubscriptionPlanUpdateEvent $event): void { $plan = $event-&gt;getPlan(); // Update the plan in the database $this-&gt;entityManager-&gt;persist($plan); $this-&gt;entityManager-&gt;flush(); } /** * Check if a plan can be safely deleted and mark it for deletion if possible. */ public function onPlanDelete(SubscriptionPlanDeleteEvent $event): void { $plan = $event-&gt;getPlan(); // Check if the plan has any active subscriptions $activeSubscriptions = $this-&gt;subscriptionRepository-&gt;findActiveByPlan($plan); if (count($activeSubscriptions) &gt; 0) { // The plan has active subscriptions, so it can't be deleted $event-&gt;setCanDelete(false, 'Plan has active subscriptions'); return; } // The plan can be deleted $event-&gt;setCanDelete(true); // Mark the plan as deleted in the database // You might want to add a 'deleted' field to your SubscriptionPlan entity // $plan-&gt;setDeleted(true); // $this-&gt;entityManager-&gt;persist($plan); // $this-&gt;entityManager-&gt;flush(); } /** * Create a new plan from a configuration. */ private function createPlanFromConfig(SubscriptionPlanConfig $config): SubscriptionPlan { $plan = new SubscriptionPlan(); $plan-&gt;setId($config-&gt;getId()); $plan-&gt;setName($config-&gt;getName()); $plan-&gt;setDescription($config-&gt;getDescription()); $plan-&gt;setAmount($config-&gt;getAmount()); $plan-&gt;setCurrency($config-&gt;getCurrency()); $plan-&gt;setInterval($config-&gt;getInterval()); $plan-&gt;setTrialPeriodDays($config-&gt;getTrialPeriodDays()); return $plan; } } . 2. Register the Event Subscriber . Make sure your event subscriber is registered as a service: . # config/services.yaml services: # ... App\\EventSubscriber\\SubscriptionPlanEventSubscriber: tags: - { name: kernel.event_subscriber } . ",
    "url": "/stripe-symfony/docs/integration/event-listeners/#subscription-plan-events",
    
    "relUrl": "/docs/integration/event-listeners/#subscription-plan-events"
  },"79": {
    "doc": "Event Listeners",
    "title": "Webhook Events",
    "content": "The Stripe Bundle converts Stripe webhook events into Symfony events with the prefix stripe. followed by the Stripe event name with underscores instead of dots. For example, the Stripe event customer.subscription.created becomes the Symfony event stripe.customer_subscription_created. 1. Create a Webhook Event Subscriber . &lt;?php namespace App\\EventSubscriber; use App\\Entity\\Invoice; use App\\Entity\\Subscription; use App\\Repository\\SubscriptionPlanRepository; use App\\Repository\\UserRepository; use Doctrine\\ORM\\EntityManagerInterface; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Tomedio\\StripeBundle\\Enum\\InvoiceStatus; use Tomedio\\StripeBundle\\Enum\\SubscriptionStatus; use Tomedio\\StripeBundle\\Event\\StripeWebhookEvent; class StripeWebhookSubscriber implements EventSubscriberInterface { private UserRepository $userRepository; private SubscriptionPlanRepository $planRepository; private EntityManagerInterface $entityManager; public function __construct( UserRepository $userRepository, SubscriptionPlanRepository $planRepository, EntityManagerInterface $entityManager ) { $this-&gt;userRepository = $userRepository; $this-&gt;planRepository = $planRepository; $this-&gt;entityManager = $entityManager; } public static function getSubscribedEvents(): array { return [ 'stripe.customer_subscription_created' =&gt; 'onSubscriptionCreated', 'stripe.customer_subscription_updated' =&gt; 'onSubscriptionUpdated', 'stripe.customer_subscription_deleted' =&gt; 'onSubscriptionDeleted', 'stripe.invoice_paid' =&gt; 'onInvoicePaid', 'stripe.invoice_payment_failed' =&gt; 'onInvoicePaymentFailed', 'stripe.checkout_session_completed' =&gt; 'onCheckoutSessionCompleted', ]; } public function onSubscriptionCreated(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $stripeSubscription = $stripeEvent-&gt;data-&gt;object; // Get the customer ID from the subscription $customerId = $stripeSubscription-&gt;customer; // Find the user by Stripe customer ID $user = $this-&gt;userRepository-&gt;findOneByStripeCustomerId($customerId); if (!$user) { return; } // Get the plan ID from the subscription $stripePriceId = $stripeSubscription-&gt;items-&gt;data[0]-&gt;price-&gt;id; // Find the plan by Stripe price ID $plan = $this-&gt;planRepository-&gt;findOneByStripePriceId($stripePriceId); if (!$plan) { return; } // Create a new subscription $subscription = new Subscription(); $subscription-&gt;setUser($user); $subscription-&gt;setPlan($plan); $subscription-&gt;setStripeSubscriptionId($stripeSubscription-&gt;id); $subscription-&gt;setStatus(SubscriptionStatus::from($stripeSubscription-&gt;status)); // Set dates $startDate = new \\DateTime('@' . $stripeSubscription-&gt;current_period_start); $endDate = new \\DateTime('@' . $stripeSubscription-&gt;current_period_end); $subscription-&gt;setStartDate($startDate); $subscription-&gt;setEndDate($endDate); // Set trial end date if applicable if ($stripeSubscription-&gt;trial_end) { $trialEndDate = new \\DateTime('@' . $stripeSubscription-&gt;trial_end); $subscription-&gt;setTrialEndDate($trialEndDate); } // Save the subscription $this-&gt;entityManager-&gt;persist($subscription); // Set the subscription as the user's active subscription $user-&gt;setActiveSubscription($subscription); $this-&gt;entityManager-&gt;persist($user); $this-&gt;entityManager-&gt;flush(); } public function onSubscriptionUpdated(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $stripeSubscription = $stripeEvent-&gt;data-&gt;object; // Find the subscription by Stripe subscription ID $subscription = $this-&gt;subscriptionRepository-&gt;findOneByStripeSubscriptionId($stripeSubscription-&gt;id); if (!$subscription) { return; } // Update the subscription status $subscription-&gt;setStatus(SubscriptionStatus::from($stripeSubscription-&gt;status)); // Update dates $startDate = new \\DateTime('@' . $stripeSubscription-&gt;current_period_start); $endDate = new \\DateTime('@' . $stripeSubscription-&gt;current_period_end); $subscription-&gt;setStartDate($startDate); $subscription-&gt;setEndDate($endDate); // Update trial end date if applicable if ($stripeSubscription-&gt;trial_end) { $trialEndDate = new \\DateTime('@' . $stripeSubscription-&gt;trial_end); $subscription-&gt;setTrialEndDate($trialEndDate); } else { $subscription-&gt;setTrialEndDate(null); } // Save the subscription $this-&gt;entityManager-&gt;persist($subscription); $this-&gt;entityManager-&gt;flush(); } public function onSubscriptionDeleted(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $stripeSubscription = $stripeEvent-&gt;data-&gt;object; // Find the subscription by Stripe subscription ID $subscription = $this-&gt;subscriptionRepository-&gt;findOneByStripeSubscriptionId($stripeSubscription-&gt;id); if (!$subscription) { return; } // Update the subscription status $subscription-&gt;setStatus(SubscriptionStatus::CANCELED); // Save the subscription $this-&gt;entityManager-&gt;persist($subscription); // If this is the user's active subscription, remove it $user = $subscription-&gt;getUser(); if ($user-&gt;getActiveSubscription() &amp;&amp; $user-&gt;getActiveSubscription()-&gt;getId() === $subscription-&gt;getId()) { $user-&gt;setActiveSubscription(null); $this-&gt;entityManager-&gt;persist($user); } $this-&gt;entityManager-&gt;flush(); } public function onInvoicePaid(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $stripeInvoice = $stripeEvent-&gt;data-&gt;object; // Get the customer ID from the invoice $customerId = $stripeInvoice-&gt;customer; // Find the user by Stripe customer ID $user = $this-&gt;userRepository-&gt;findOneByStripeCustomerId($customerId); if (!$user) { return; } // Create a new invoice $invoice = new Invoice(); $invoice-&gt;setUser($user); $invoice-&gt;setStripeInvoiceId($stripeInvoice-&gt;id); $invoice-&gt;setAmount($stripeInvoice-&gt;amount_paid); $invoice-&gt;setCurrency(Currency::from(strtoupper($stripeInvoice-&gt;currency))); $invoice-&gt;setStatus(InvoiceStatus::PAID); // Set dates $invoiceDate = new \\DateTime('@' . $stripeInvoice-&gt;created); $paidDate = new \\DateTime('@' . $stripeInvoice-&gt;status_transitions-&gt;paid_at); $invoice-&gt;setInvoiceDate($invoiceDate); $invoice-&gt;setPaidDate($paidDate); // If the invoice is for a subscription, link it if ($stripeInvoice-&gt;subscription) { $subscription = $this-&gt;subscriptionRepository-&gt;findOneByStripeSubscriptionId($stripeInvoice-&gt;subscription); if ($subscription) { $invoice-&gt;setSubscription($subscription); } } // Save the invoice $this-&gt;entityManager-&gt;persist($invoice); $this-&gt;entityManager-&gt;flush(); } public function onInvoicePaymentFailed(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $stripeInvoice = $stripeEvent-&gt;data-&gt;object; // Get the customer ID from the invoice $customerId = $stripeInvoice-&gt;customer; // Find the user by Stripe customer ID $user = $this-&gt;userRepository-&gt;findOneByStripeCustomerId($customerId); if (!$user) { return; } // Create a new invoice or update an existing one $invoice = $this-&gt;invoiceRepository-&gt;findOneByStripeInvoiceId($stripeInvoice-&gt;id); if (!$invoice) { $invoice = new Invoice(); $invoice-&gt;setUser($user); $invoice-&gt;setStripeInvoiceId($stripeInvoice-&gt;id); } $invoice-&gt;setAmount($stripeInvoice-&gt;amount_due); $invoice-&gt;setCurrency(Currency::from(strtoupper($stripeInvoice-&gt;currency))); $invoice-&gt;setStatus(InvoiceStatus::FAILED); // Set dates $invoiceDate = new \\DateTime('@' . $stripeInvoice-&gt;created); $invoice-&gt;setInvoiceDate($invoiceDate); // If the invoice is for a subscription, link it if ($stripeInvoice-&gt;subscription) { $subscription = $this-&gt;subscriptionRepository-&gt;findOneByStripeSubscriptionId($stripeInvoice-&gt;subscription); if ($subscription) { $invoice-&gt;setSubscription($subscription); } } // Save the invoice $this-&gt;entityManager-&gt;persist($invoice); $this-&gt;entityManager-&gt;flush(); } public function onCheckoutSessionCompleted(StripeWebhookEvent $event): void { $stripeEvent = $event-&gt;getStripeEvent(); $session = $stripeEvent-&gt;data-&gt;object; // Get the customer ID from the session $customerId = $session-&gt;customer; // Find the user by Stripe customer ID $user = $this-&gt;userRepository-&gt;findOneByStripeCustomerId($customerId); if (!$user) { return; } // Handle different checkout modes switch ($session-&gt;mode) { case 'subscription': // Subscription checkout is handled by the onSubscriptionCreated event break; case 'payment': // Handle one-time payment (e.g., credit purchase) if (isset($session-&gt;metadata-&gt;credits)) { $credits = (int) $session-&gt;metadata-&gt;credits; // Add credits to the user's balance $this-&gt;creditService-&gt;addCredits( $user, $credits, 'Credit purchase', CreditTransactionType::PURCHASE, 'session_' . $session-&gt;id ); } break; } } } . 2. Register the Webhook Event Subscriber . # config/services.yaml services: # ... App\\EventSubscriber\\StripeWebhookSubscriber: tags: - { name: kernel.event_subscriber } . ",
    "url": "/stripe-symfony/docs/integration/event-listeners/#webhook-events",
    
    "relUrl": "/docs/integration/event-listeners/#webhook-events"
  },"80": {
    "doc": "Event Listeners",
    "title": "Credit Events",
    "content": "The Stripe Bundle dispatches events when credits are added or used. 1. Create a Credit Event Subscriber . &lt;?php namespace App\\EventSubscriber; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Tomedio\\StripeBundle\\Event\\CreditPurchaseEvent; use Tomedio\\StripeBundle\\Event\\CreditUsageEvent; class CreditEventSubscriber implements EventSubscriberInterface { public static function getSubscribedEvents(): array { return [ CreditPurchaseEvent::class =&gt; 'onCreditPurchase', CreditUsageEvent::class =&gt; 'onCreditUsage', ]; } public function onCreditPurchase(CreditPurchaseEvent $event): void { $user = $event-&gt;getUser(); $amount = $event-&gt;getAmount(); $transaction = $event-&gt;getTransaction(); // You can perform additional actions when credits are purchased // For example, send a notification to the user } public function onCreditUsage(CreditUsageEvent $event): void { $user = $event-&gt;getUser(); $amount = $event-&gt;getAmount(); $transaction = $event-&gt;getTransaction(); // You can perform additional actions when credits are used // For example, log usage statistics or send a notification when the balance is low if ($user-&gt;getCreditsBalance() &lt; 10) { // Send a low balance notification } } } . 2. Register the Credit Event Subscriber . # config/services.yaml services: # ... App\\EventSubscriber\\CreditEventSubscriber: tags: - { name: kernel.event_subscriber } . ",
    "url": "/stripe-symfony/docs/integration/event-listeners/#credit-events",
    
    "relUrl": "/docs/integration/event-listeners/#credit-events"
  },"81": {
    "doc": "Event Listeners",
    "title": "API Platform Events",
    "content": "If you’re using API Platform, you can use its event system to integrate with the Stripe Bundle. 1. Create an API Platform Event Subscriber . &lt;?php namespace App\\EventSubscriber; use ApiPlatform\\Symfony\\EventListener\\EventPriorities; use App\\Entity\\User; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Symfony\\Component\\HttpKernel\\Event\\ViewEvent; use Symfony\\Component\\HttpKernel\\KernelEvents; use Tomedio\\StripeBundle\\Service\\CustomerService; class ApiUserCreationSubscriber implements EventSubscriberInterface { private CustomerService $customerService; public function __construct(CustomerService $customerService) { $this-&gt;customerService = $customerService; } public static function getSubscribedEvents(): array { return [ KernelEvents::VIEW =&gt; ['onUserCreated', EventPriorities::POST_WRITE], ]; } public function onUserCreated(ViewEvent $event): void { $user = $event-&gt;getControllerResult(); $method = $event-&gt;getRequest()-&gt;getMethod(); // Only process POST requests for User entities if (!$user instanceof User || $method !== 'POST') { return; } // Create a Stripe customer for the new user if (!$user-&gt;getStripeCustomerId()) { $this-&gt;customerService-&gt;getOrCreateCustomer($user); } } } . 2. Register the API Platform Event Subscriber . # config/services.yaml services: # ... App\\EventSubscriber\\ApiUserCreationSubscriber: tags: - { name: kernel.event_subscriber } . ",
    "url": "/stripe-symfony/docs/integration/event-listeners/#api-platform-events",
    
    "relUrl": "/docs/integration/event-listeners/#api-platform-events"
  },"82": {
    "doc": "Event Listeners",
    "title": "Best Practices",
    "content": ". | Error Handling: Implement proper error handling in your event subscribers | Logging: Log important events for debugging and auditing purposes | Idempotency: Ensure your event handlers are idempotent, as events may be dispatched multiple times | Transaction Management: Use database transactions to ensure data consistency | Event Propagation: Be mindful of event propagation and stopping it when necessary | Performance: Keep event handlers lightweight and consider using message queues for time-consuming operations | . ",
    "url": "/stripe-symfony/docs/integration/event-listeners/#best-practices",
    
    "relUrl": "/docs/integration/event-listeners/#best-practices"
  },"83": {
    "doc": "Events",
    "title": "Events",
    "content": " ",
    "url": "/stripe-symfony/docs/integration/events/",
    
    "relUrl": "/docs/integration/events/"
  },"84": {
    "doc": "Events",
    "title": "Table of contents",
    "content": ". | Overview | Subscription Plan Events . | SubscriptionPlanListEvent | SubscriptionPlanLoadEvent | SubscriptionPlanCreateEvent | SubscriptionPlanUpdateEvent | SubscriptionPlanDeleteEvent | SubscriptionPlanSyncEvent | . | Subscription Events . | SubscriptionCreatedEvent | . | Invoice Events . | InvoiceCreatedEvent | InvoiceSubscriptionEvent | . | Credit Events . | CreditPurchaseEvent | CreditUsageEvent | . | User Events . | StripeUserLoadEvent | FindUserByStripeCustomerEvent | . | Webhook Events . | StripeWebhookEvent | Specific Webhook Events | . | Implementing Event Listeners . | 1. Create an Event Subscriber | 2. Register the Event Subscriber | . | Best Practices | . ",
    "url": "/stripe-symfony/docs/integration/events/#table-of-contents",
    
    "relUrl": "/docs/integration/events/#table-of-contents"
  },"85": {
    "doc": "Events",
    "title": "Overview",
    "content": "The Stripe Bundle uses Symfony’s event system to communicate between different components and to allow your application to react to various events. This approach provides a clean separation of concerns and makes the bundle highly extensible. This page provides a comprehensive reference of all events dispatched by the bundle that you can listen to in your application. ",
    "url": "/stripe-symfony/docs/integration/events/#overview",
    
    "relUrl": "/docs/integration/events/#overview"
  },"86": {
    "doc": "Events",
    "title": "Subscription Plan Events",
    "content": "These events are dispatched during the subscription plan management process. SubscriptionPlanListEvent . Dispatched when the bundle needs to retrieve all subscription plans from your application. | Event Class: Tomedio\\StripeBundle\\Event\\SubscriptionPlanListEvent | Event Name: stripe.plan.list | Purpose: Retrieve all subscription plans from your application’s database | Methods: . | getPlans(): Get the plans that have been set | setPlans(array $plans): Set the plans to be returned to the bundle | . | . SubscriptionPlanLoadEvent . Dispatched when the bundle needs to load a specific subscription plan. | Event Class: Tomedio\\StripeBundle\\Event\\SubscriptionPlanLoadEvent | Event Name: stripe.plan.load | Purpose: Load a specific plan from your application’s database or create a new one if it doesn’t exist | Methods: . | getPlanId(): Get the ID of the plan to load | getConfig(): Get the configuration for the plan | getPlan(): Get the plan that has been set | setPlan(SubscriptionPlanInterface $plan): Set the plan to be returned to the bundle | hasPlan(): Check if a plan has been set | . | . SubscriptionPlanCreateEvent . Dispatched when a new subscription plan needs to be created. | Event Class: Tomedio\\StripeBundle\\Event\\SubscriptionPlanCreateEvent | Event Name: stripe.plan.create | Purpose: Create a new subscription plan in your application’s database | Methods: . | getPlan(): Get the plan to be created | . | . SubscriptionPlanUpdateEvent . Dispatched when an existing subscription plan needs to be updated. | Event Class: Tomedio\\StripeBundle\\Event\\SubscriptionPlanUpdateEvent | Event Name: stripe.plan.update | Purpose: Update an existing subscription plan in your application’s database | Methods: . | getPlan(): Get the plan to be updated | . | . SubscriptionPlanDeleteEvent . Dispatched when a subscription plan needs to be deleted or deactivated. | Event Class: Tomedio\\StripeBundle\\Event\\SubscriptionPlanDeleteEvent | Event Name: stripe.plan.delete | Purpose: Check if a plan can be safely deleted and mark it for deletion if possible | Methods: . | getPlan(): Get the plan to be deleted | setCanDelete(bool $canDelete, ?string $reason = null): Set whether the plan can be deleted and optionally provide a reason | canDelete(): Check if the plan can be deleted | getReason(): Get the reason why the plan cannot be deleted | . | . SubscriptionPlanSyncEvent . Dispatched during the synchronization of subscription plans with Stripe. | Event Class: Tomedio\\StripeBundle\\Event\\SubscriptionPlanSyncEvent | Event Name: stripe.plan.sync | Purpose: Notify your application that a plan is being synchronized with Stripe | Methods: . | getPlanId(): Get the ID of the plan being synchronized | getConfigData(): Get the configuration data for the plan | . | . ",
    "url": "/stripe-symfony/docs/integration/events/#subscription-plan-events",
    
    "relUrl": "/docs/integration/events/#subscription-plan-events"
  },"87": {
    "doc": "Events",
    "title": "Subscription Events",
    "content": "These events are dispatched during subscription management. SubscriptionCreatedEvent . Dispatched when a new subscription is created in Stripe. | Event Class: Tomedio\\StripeBundle\\Event\\SubscriptionCreatedEvent | Event Name: stripe.subscription.created | Purpose: Create a new subscription entity in your application’s database | Methods: . | getUser(): Get the user who created the subscription | getStripeSubscription(): Get the Stripe subscription object | getSubscription(): Get the subscription entity that has been set | setSubscription(SubscriptionInterface $subscription): Set the subscription entity to be returned to the bundle | hasSubscription(): Check if a subscription entity has been set | . | . ",
    "url": "/stripe-symfony/docs/integration/events/#subscription-events",
    
    "relUrl": "/docs/integration/events/#subscription-events"
  },"88": {
    "doc": "Events",
    "title": "Invoice Events",
    "content": "These events are dispatched during invoice management. InvoiceCreatedEvent . Dispatched when a new invoice is created in Stripe. | Event Class: Tomedio\\StripeBundle\\Event\\InvoiceCreatedEvent | Event Name: stripe.invoice.created | Purpose: Create a new invoice entity in your application’s database | Methods: . | getUser(): Get the user associated with the invoice | getStripeInvoice(): Get the Stripe invoice object | getInvoice(): Get the invoice entity that has been set | setInvoice(StripeInvoiceInterface $invoice): Set the invoice entity to be returned to the bundle | hasInvoice(): Check if an invoice entity has been set | . | . InvoiceSubscriptionEvent . Dispatched when an invoice is associated with a subscription. | Event Class: Tomedio\\StripeBundle\\Event\\InvoiceSubscriptionEvent | Event Name: stripe.invoice.subscription | Purpose: Find the subscription entity associated with a Stripe subscription ID | Methods: . | getStripeSubscriptionId(): Get the Stripe subscription ID | getSubscription(): Get the subscription entity that has been set | setSubscription(SubscriptionInterface $subscription): Set the subscription entity to be returned to the bundle | hasSubscription(): Check if a subscription entity has been set | . | . ",
    "url": "/stripe-symfony/docs/integration/events/#invoice-events",
    
    "relUrl": "/docs/integration/events/#invoice-events"
  },"89": {
    "doc": "Events",
    "title": "Credit Events",
    "content": "These events are dispatched during credit management. CreditPurchaseEvent . Dispatched when a user purchases credits. | Event Class: Tomedio\\StripeBundle\\Event\\CreditPurchaseEvent | Event Name: stripe.credits.purchase | Purpose: Notify your application that a user has purchased credits | Methods: . | getUser(): Get the user who purchased the credits | getCredits(): Get the number of credits purchased | getDescription(): Get the description of the purchase | getPaymentIntentId(): Get the Stripe payment intent ID | getAmount(): Get the amount paid in the smallest currency unit (e.g., cents) | getCurrency(): Get the currency used for the payment | . | . CreditUsageEvent . Dispatched when a user uses credits. | Event Class: Tomedio\\StripeBundle\\Event\\CreditUsageEvent | Event Name: stripe.credits.usage | Purpose: Notify your application that a user has used credits | Methods: . | getUser(): Get the user who used the credits | getCredits(): Get the number of credits used | getDescription(): Get the description of the usage | getReferenceId(): Get the reference ID for the transaction | . | . ",
    "url": "/stripe-symfony/docs/integration/events/#credit-events",
    
    "relUrl": "/docs/integration/events/#credit-events"
  },"90": {
    "doc": "Events",
    "title": "User Events",
    "content": "These events are dispatched during user management. StripeUserLoadEvent . Dispatched when the bundle needs to find a user by their Stripe customer ID. | Event Class: Tomedio\\StripeBundle\\Event\\StripeUserLoadEvent | Event Name: stripe.user.load | Purpose: Find a user entity by their Stripe customer ID | Methods: . | getStripeCustomerId(): Get the Stripe customer ID | getUserId(): Get the user ID from Stripe metadata | getUser(): Get the user entity that has been set | setUser(?StripeUserInterface $user): Set the user entity to be returned to the bundle | . | . FindUserByStripeCustomerEvent . Dispatched when the bundle needs to find a user by both their Stripe customer ID and user ID. | Event Class: Tomedio\\StripeBundle\\Event\\FindUserByStripeCustomerEvent | Event Name: stripe.user.find_by_customer | Purpose: Find a user entity by their Stripe customer ID and user ID | Methods: . | getStripeCustomerId(): Get the Stripe customer ID | getUserId(): Get the user ID | getUser(): Get the user entity that has been set | setUser(?StripeUserInterface $user): Set the user entity to be returned to the bundle | . | . ",
    "url": "/stripe-symfony/docs/integration/events/#user-events",
    
    "relUrl": "/docs/integration/events/#user-events"
  },"91": {
    "doc": "Events",
    "title": "Webhook Events",
    "content": "These events are dispatched when Stripe webhook events are received. StripeWebhookEvent . Dispatched for all Stripe webhook events. | Event Class: Tomedio\\StripeBundle\\Event\\StripeWebhookEvent | Event Name: stripe.webhook (generic) and stripe.[event_type] (specific) | Purpose: Process Stripe webhook events | Methods: . | getStripeEvent(): Get the Stripe event object | getType(): Get the type of the Stripe event | getData(): Get the data object from the Stripe event | . | . Specific Webhook Events . The bundle converts Stripe webhook events into Symfony events with the prefix stripe. followed by the Stripe event name with underscores instead of dots. For example, the Stripe event customer.subscription.created becomes the Symfony event stripe.customer_subscription_created. Here are some common webhook events: . | stripe.customer_subscription_created: Dispatched when a subscription is created | stripe.customer_subscription_updated: Dispatched when a subscription is updated | stripe.customer_subscription_deleted: Dispatched when a subscription is deleted | stripe.invoice_paid: Dispatched when an invoice is paid | stripe.invoice_payment_failed: Dispatched when an invoice payment fails | stripe.checkout_session_completed: Dispatched when a checkout session is completed | . ",
    "url": "/stripe-symfony/docs/integration/events/#webhook-events",
    
    "relUrl": "/docs/integration/events/#webhook-events"
  },"92": {
    "doc": "Events",
    "title": "Implementing Event Listeners",
    "content": "1. Create an Event Subscriber . &lt;?php namespace App\\EventSubscriber; use Symfony\\Component\\EventDispatcher\\EventSubscriberInterface; use Tomedio\\StripeBundle\\Event\\CreditPurchaseEvent; use Tomedio\\StripeBundle\\Event\\CreditUsageEvent; class CreditEventSubscriber implements EventSubscriberInterface { public static function getSubscribedEvents(): array { return [ CreditPurchaseEvent::class =&gt; 'onCreditPurchase', CreditUsageEvent::class =&gt; 'onCreditUsage', ]; } public function onCreditPurchase(CreditPurchaseEvent $event): void { $user = $event-&gt;getUser(); $credits = $event-&gt;getCredits(); // You can perform additional actions when credits are purchased // For example, send a notification to the user } public function onCreditUsage(CreditUsageEvent $event): void { $user = $event-&gt;getUser(); $credits = $event-&gt;getCredits(); // You can perform additional actions when credits are used // For example, log usage statistics or send a notification when the balance is low if ($user-&gt;getCreditsBalance() &lt; 10) { // Send a low balance notification } } } . 2. Register the Event Subscriber . # config/services.yaml services: # ... App\\EventSubscriber\\CreditEventSubscriber: tags: - { name: kernel.event_subscriber } . ",
    "url": "/stripe-symfony/docs/integration/events/#implementing-event-listeners",
    
    "relUrl": "/docs/integration/events/#implementing-event-listeners"
  },"93": {
    "doc": "Events",
    "title": "Best Practices",
    "content": ". | Error Handling: Implement proper error handling in your event subscribers | Logging: Log important events for debugging and auditing purposes | Idempotency: Ensure your event handlers are idempotent, as events may be dispatched multiple times | Transaction Management: Use database transactions to ensure data consistency | Event Propagation: Be mindful of event propagation and stopping it when necessary | Performance: Keep event handlers lightweight and consider using message queues for time-consuming operations | . ",
    "url": "/stripe-symfony/docs/integration/events/#best-practices",
    
    "relUrl": "/docs/integration/events/#best-practices"
  },"94": {
    "doc": "Implementing Interfaces",
    "title": "Implementing Interfaces",
    "content": " ",
    "url": "/stripe-symfony/docs/integration/implementing-interfaces/",
    
    "relUrl": "/docs/integration/implementing-interfaces/"
  },"95": {
    "doc": "Implementing Interfaces",
    "title": "Table of contents",
    "content": ". | Overview | Required Interfaces . | StripeUserInterface | AddressInterface | SubscriptionPlanInterface | SubscriptionInterface | StripeInvoiceInterface | CreditTransactionInterface | . | Repository Interfaces | Next Steps | . ",
    "url": "/stripe-symfony/docs/integration/implementing-interfaces/#table-of-contents",
    
    "relUrl": "/docs/integration/implementing-interfaces/#table-of-contents"
  },"96": {
    "doc": "Implementing Interfaces",
    "title": "Overview",
    "content": "The Stripe Bundle uses interfaces to define the contract between your application entities and the bundle’s services. This approach allows you to integrate the bundle with your existing entity structure without forcing a specific implementation. This page covers the key interfaces you need to implement in your application. ",
    "url": "/stripe-symfony/docs/integration/implementing-interfaces/#overview",
    
    "relUrl": "/docs/integration/implementing-interfaces/#overview"
  },"97": {
    "doc": "Implementing Interfaces",
    "title": "Required Interfaces",
    "content": "StripeUserInterface . This interface should be implemented by your User entity or any entity that represents a customer in your application. &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Symfony\\Component\\Security\\Core\\User\\UserInterface as SymfonyUserInterface; use Tomedio\\StripeBundle\\Contract\\AddressInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; use Tomedio\\StripeBundle\\Contract\\SubscriptionInterface; use Tomedio\\StripeBundle\\Enum\\Currency; #[ORM\\Entity] class User implements SymfonyUserInterface, StripeUserInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private ?int $id = null; #[ORM\\Column(type: 'string', length: 180, unique: true)] private string $email; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $name = null; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripeCustomerId = null; #[ORM\\ManyToOne(targetEntity: Address::class, cascade: ['persist'])] private ?AddressInterface $billingAddress = null; #[ORM\\Column(type: 'integer', nullable: true)] private ?int $stripeBalance = null; #[ORM\\Column(type: 'string', length: 3, nullable: true, enumType: Currency::class)] private ?Currency $stripeBalanceCurrency = null; #[ORM\\OneToOne(targetEntity: Subscription::class)] private ?SubscriptionInterface $activeSubscription = null; #[ORM\\Column(type: 'datetime', nullable: true)] private ?\\DateTimeInterface $stripeCreatedAt = null; #[ORM\\Column(type: 'integer')] private int $creditsBalance = 0; // Implement getters and setters for all properties public function getStripeCustomerId(): ?string { return $this-&gt;stripeCustomerId; } public function setStripeCustomerId(?string $stripeCustomerId): self { $this-&gt;stripeCustomerId = $stripeCustomerId; return $this; } public function getEmail(): string { return $this-&gt;email; } public function getName(): ?string { return $this-&gt;name; } public function getBillingAddress(): ?AddressInterface { return $this-&gt;billingAddress; } public function setBillingAddress(?AddressInterface $billingAddress): self { $this-&gt;billingAddress = $billingAddress; return $this; } public function getActiveSubscription(): ?SubscriptionInterface { return $this-&gt;activeSubscription; } public function setActiveSubscription(?SubscriptionInterface $subscription): self { $this-&gt;activeSubscription = $subscription; return $this; } public function getStripeBalance(): ?int { return $this-&gt;stripeBalance; } public function setStripeBalance(?int $stripeBalance): self { $this-&gt;stripeBalance = $stripeBalance; return $this; } public function getStripeBalanceCurrency(): ?Currency { return $this-&gt;stripeBalanceCurrency; } public function setStripeBalanceCurrency(?Currency $stripeBalanceCurrency): self { $this-&gt;stripeBalanceCurrency = $stripeBalanceCurrency; return $this; } public function getStripeCreatedAt(): ?\\DateTimeInterface { return $this-&gt;stripeCreatedAt; } public function setStripeCreatedAt(?\\DateTimeInterface $stripeCreatedAt): self { $this-&gt;stripeCreatedAt = $stripeCreatedAt; return $this; } public function getCreditsBalance(): int { return $this-&gt;creditsBalance; } public function setCreditsBalance(int $creditsBalance): self { $this-&gt;creditsBalance = $creditsBalance; return $this; } // Implement other methods required by SymfonyUserInterface } . AddressInterface . This interface represents a billing address for a customer. &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Contract\\AddressInterface; #[ORM\\Entity] class Address implements AddressInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private ?int $id = null; #[ORM\\Column(type: 'string', length: 255)] private string $line1; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $line2 = null; #[ORM\\Column(type: 'string', length: 255)] private string $city; #[ORM\\Column(type: 'string', length: 255)] private string $state; #[ORM\\Column(type: 'string', length: 255)] private string $postalCode; #[ORM\\Column(type: 'string', length: 2)] private string $country; // Implement getters and setters for all properties public function getLine1(): string { return $this-&gt;line1; } public function setLine1(string $line1): self { $this-&gt;line1 = $line1; return $this; } public function getLine2(): ?string { return $this-&gt;line2; } public function setLine2(?string $line2): self { $this-&gt;line2 = $line2; return $this; } public function getCity(): string { return $this-&gt;city; } public function setState(string $state): self { $this-&gt;state = $state; return $this; } public function getState(): string { return $this-&gt;state; } public function setCity(string $city): self { $this-&gt;city = $city; return $this; } public function getPostalCode(): string { return $this-&gt;postalCode; } public function setPostalCode(string $postalCode): self { $this-&gt;postalCode = $postalCode; return $this; } public function getCountry(): string { return $this-&gt;country; } public function setCountry(string $country): self { $this-&gt;country = $country; return $this; } } . SubscriptionPlanInterface . This interface represents a subscription plan in your application. &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Contract\\SubscriptionPlanInterface; use Tomedio\\StripeBundle\\Enum\\BillingInterval; use Tomedio\\StripeBundle\\Enum\\Currency; #[ORM\\Entity] class SubscriptionPlan implements SubscriptionPlanInterface { #[ORM\\Id] #[ORM\\Column(type: 'string', length: 255)] private string $id; #[ORM\\Column(type: 'string', length: 255)] private string $name; #[ORM\\Column(type: 'text', nullable: true)] private ?string $description = null; #[ORM\\Column(type: 'integer')] private int $amount; #[ORM\\Column(type: 'string', length: 3, enumType: Currency::class)] private Currency $currency; #[ORM\\Column(type: 'string', length: 10, enumType: BillingInterval::class)] private BillingInterval $interval; #[ORM\\Column(type: 'integer', nullable: true)] private ?int $trialPeriodDays = null; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripeProductId = null; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripePriceId = null; // Implement getters and setters for all properties public function getId(): string { return $this-&gt;id; } public function setId(string $id): self { $this-&gt;id = $id; return $this; } public function getName(): string { return $this-&gt;name; } public function setName(string $name): self { $this-&gt;name = $name; return $this; } public function getDescription(): ?string { return $this-&gt;description; } public function setDescription(?string $description): self { $this-&gt;description = $description; return $this; } public function getAmount(): int { return $this-&gt;amount; } public function setAmount(int $amount): self { $this-&gt;amount = $amount; return $this; } public function getCurrency(): Currency { return $this-&gt;currency; } public function setCurrency(Currency $currency): self { $this-&gt;currency = $currency; return $this; } public function getInterval(): BillingInterval { return $this-&gt;interval; } public function setInterval(BillingInterval $interval): self { $this-&gt;interval = $interval; return $this; } public function getTrialPeriodDays(): ?int { return $this-&gt;trialPeriodDays; } public function setTrialPeriodDays(?int $trialPeriodDays): self { $this-&gt;trialPeriodDays = $trialPeriodDays; return $this; } public function getStripeProductId(): ?string { return $this-&gt;stripeProductId; } public function setStripeProductId(?string $stripeProductId): self { $this-&gt;stripeProductId = $stripeProductId; return $this; } public function getStripePriceId(): ?string { return $this-&gt;stripePriceId; } public function setStripePriceId(?string $stripePriceId): self { $this-&gt;stripePriceId = $stripePriceId; return $this; } } . SubscriptionInterface . This interface represents a subscription in your application. &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Contract\\SubscriptionInterface; use Tomedio\\StripeBundle\\Contract\\SubscriptionPlanInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; use Tomedio\\StripeBundle\\Enum\\SubscriptionStatus; #[ORM\\Entity] class Subscription implements SubscriptionInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private ?int $id = null; #[ORM\\ManyToOne(targetEntity: User::class)] #[ORM\\JoinColumn(nullable: false)] private StripeUserInterface $user; #[ORM\\ManyToOne(targetEntity: SubscriptionPlan::class)] #[ORM\\JoinColumn(nullable: false)] private SubscriptionPlanInterface $plan; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $stripeSubscriptionId = null; #[ORM\\Column(type: 'string', length: 20, enumType: SubscriptionStatus::class)] private SubscriptionStatus $status; #[ORM\\Column(type: 'datetime', nullable: true)] private ?\\DateTimeInterface $startDate = null; #[ORM\\Column(type: 'datetime', nullable: true)] private ?\\DateTimeInterface $endDate = null; #[ORM\\Column(type: 'datetime', nullable: true)] private ?\\DateTimeInterface $trialEndDate = null; // Implement getters and setters for all properties public function getId(): ?int { return $this-&gt;id; } public function getUser(): StripeUserInterface { return $this-&gt;user; } public function setUser(StripeUserInterface $user): self { $this-&gt;user = $user; return $this; } public function getPlan(): SubscriptionPlanInterface { return $this-&gt;plan; } public function setPlan(SubscriptionPlanInterface $plan): self { $this-&gt;plan = $plan; return $this; } public function getStripeSubscriptionId(): ?string { return $this-&gt;stripeSubscriptionId; } public function setStripeSubscriptionId(?string $stripeSubscriptionId): self { $this-&gt;stripeSubscriptionId = $stripeSubscriptionId; return $this; } public function getStatus(): SubscriptionStatus { return $this-&gt;status; } public function setStatus(SubscriptionStatus $status): self { $this-&gt;status = $status; return $this; } public function getStartDate(): ?\\DateTimeInterface { return $this-&gt;startDate; } public function setStartDate(?\\DateTimeInterface $startDate): self { $this-&gt;startDate = $startDate; return $this; } public function getEndDate(): ?\\DateTimeInterface { return $this-&gt;endDate; } public function setEndDate(?\\DateTimeInterface $endDate): self { $this-&gt;endDate = $endDate; return $this; } public function getTrialEndDate(): ?\\DateTimeInterface { return $this-&gt;trialEndDate; } public function setTrialEndDate(?\\DateTimeInterface $trialEndDate): self { $this-&gt;trialEndDate = $trialEndDate; return $this; } } . StripeInvoiceInterface . This interface represents an invoice in your application. &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Contract\\StripeInvoiceInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; use Tomedio\\StripeBundle\\Contract\\SubscriptionInterface; use Tomedio\\StripeBundle\\Enum\\Currency; use Tomedio\\StripeBundle\\Enum\\InvoiceStatus; #[ORM\\Entity] class Invoice implements StripeInvoiceInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private ?int $id = null; #[ORM\\ManyToOne(targetEntity: User::class)] #[ORM\\JoinColumn(nullable: false)] private StripeUserInterface $user; #[ORM\\ManyToOne(targetEntity: Subscription::class)] private ?SubscriptionInterface $subscription = null; #[ORM\\Column(type: 'string', length: 255)] private string $stripeInvoiceId; #[ORM\\Column(type: 'integer')] private int $amount; #[ORM\\Column(type: 'string', length: 3, enumType: Currency::class)] private Currency $currency; #[ORM\\Column(type: 'string', length: 20, enumType: InvoiceStatus::class)] private InvoiceStatus $status; #[ORM\\Column(type: 'datetime')] private \\DateTimeInterface $invoiceDate; #[ORM\\Column(type: 'datetime', nullable: true)] private ?\\DateTimeInterface $dueDate = null; #[ORM\\Column(type: 'datetime', nullable: true)] private ?\\DateTimeInterface $paidDate = null; // Implement getters and setters for all properties public function getId(): ?int { return $this-&gt;id; } public function getUser(): StripeUserInterface { return $this-&gt;user; } public function setUser(StripeUserInterface $user): self { $this-&gt;user = $user; return $this; } public function getSubscription(): ?SubscriptionInterface { return $this-&gt;subscription; } public function setSubscription(?SubscriptionInterface $subscription): self { $this-&gt;subscription = $subscription; return $this; } public function getStripeInvoiceId(): string { return $this-&gt;stripeInvoiceId; } public function setStripeInvoiceId(string $stripeInvoiceId): self { $this-&gt;stripeInvoiceId = $stripeInvoiceId; return $this; } public function getAmount(): int { return $this-&gt;amount; } public function setAmount(int $amount): self { $this-&gt;amount = $amount; return $this; } public function getCurrency(): Currency { return $this-&gt;currency; } public function setCurrency(Currency $currency): self { $this-&gt;currency = $currency; return $this; } public function getStatus(): InvoiceStatus { return $this-&gt;status; } public function setStatus(InvoiceStatus $status): self { $this-&gt;status = $status; return $this; } public function getInvoiceDate(): \\DateTimeInterface { return $this-&gt;invoiceDate; } public function setInvoiceDate(\\DateTimeInterface $invoiceDate): self { $this-&gt;invoiceDate = $invoiceDate; return $this; } public function getDueDate(): ?\\DateTimeInterface { return $this-&gt;dueDate; } public function setDueDate(?\\DateTimeInterface $dueDate): self { $this-&gt;dueDate = $dueDate; return $this; } public function getPaidDate(): ?\\DateTimeInterface { return $this-&gt;paidDate; } public function setPaidDate(?\\DateTimeInterface $paidDate): self { $this-&gt;paidDate = $paidDate; return $this; } } . CreditTransactionInterface . This interface represents a credit transaction in your application. &lt;?php namespace App\\Entity; use Doctrine\\ORM\\Mapping as ORM; use Tomedio\\StripeBundle\\Contract\\CreditTransactionInterface; use Tomedio\\StripeBundle\\Contract\\StripeUserInterface; use Tomedio\\StripeBundle\\Enum\\CreditTransactionType; use Tomedio\\StripeBundle\\Enum\\Currency; #[ORM\\Entity] class CreditTransaction implements CreditTransactionInterface { #[ORM\\Id] #[ORM\\GeneratedValue] #[ORM\\Column(type: 'integer')] private ?int $id = null; #[ORM\\ManyToOne(targetEntity: User::class)] #[ORM\\JoinColumn(nullable: false)] private StripeUserInterface $user; #[ORM\\Column(type: 'integer')] private int $amount; #[ORM\\Column(type: 'integer')] private int $balanceAfter; #[ORM\\Column(type: 'string', length: 255)] private string $description; #[ORM\\Column(type: 'datetime')] private \\DateTimeInterface $transactionDate; #[ORM\\Column(type: 'string', length: 20, enumType: CreditTransactionType::class)] private CreditTransactionType $type; #[ORM\\Column(type: 'string', length: 255, nullable: true)] private ?string $referenceId = null; #[ORM\\Column(type: 'integer', nullable: true)] private ?int $monetaryAmount = null; #[ORM\\Column(type: 'string', length: 3, nullable: true, enumType: Currency::class)] private ?Currency $currency = null; // Implement getters and setters for all properties public function getId(): ?int { return $this-&gt;id; } public function getUser(): StripeUserInterface { return $this-&gt;user; } public function setUser(StripeUserInterface $user): self { $this-&gt;user = $user; return $this; } public function getAmount(): int { return $this-&gt;amount; } public function setAmount(int $amount): self { $this-&gt;amount = $amount; return $this; } public function getBalanceAfter(): int { return $this-&gt;balanceAfter; } public function setBalanceAfter(int $balanceAfter): self { $this-&gt;balanceAfter = $balanceAfter; return $this; } public function getDescription(): string { return $this-&gt;description; } public function setDescription(string $description): self { $this-&gt;description = $description; return $this; } public function getTransactionDate(): \\DateTimeInterface { return $this-&gt;transactionDate; } public function setTransactionDate(\\DateTimeInterface $transactionDate): self { $this-&gt;transactionDate = $transactionDate; return $this; } public function getType(): CreditTransactionType { return $this-&gt;type; } public function setType(CreditTransactionType $type): self { $this-&gt;type = $type; return $this; } public function getReferenceId(): ?string { return $this-&gt;referenceId; } public function setReferenceId(?string $referenceId): self { $this-&gt;referenceId = $referenceId; return $this; } public function getMonetaryAmount(): ?int { return $this-&gt;monetaryAmount; } public function setMonetaryAmount(?int $monetaryAmount): self { $this-&gt;monetaryAmount = $monetaryAmount; return $this; } public function getCurrency(): ?Currency { return $this-&gt;currency; } public function setCurrency(?Currency $currency): self { $this-&gt;currency = $currency; return $this; } } . ",
    "url": "/stripe-symfony/docs/integration/implementing-interfaces/#required-interfaces",
    
    "relUrl": "/docs/integration/implementing-interfaces/#required-interfaces"
  },"98": {
    "doc": "Implementing Interfaces",
    "title": "Repository Interfaces",
    "content": "In addition to the entity interfaces, you’ll need to implement repository classes for your entities. These repositories should extend Doctrine’s ServiceEntityRepository class. Here’s an example for the SubscriptionPlanRepository: . &lt;?php namespace App\\Repository; use App\\Entity\\SubscriptionPlan; use Doctrine\\Bundle\\DoctrineBundle\\Repository\\ServiceEntityRepository; use Doctrine\\Persistence\\ManagerRegistry; class SubscriptionPlanRepository extends ServiceEntityRepository { public function __construct(ManagerRegistry $registry) { parent::__construct($registry, SubscriptionPlan::class); } // Add any custom repository methods you need } . ",
    "url": "/stripe-symfony/docs/integration/implementing-interfaces/#repository-interfaces",
    
    "relUrl": "/docs/integration/implementing-interfaces/#repository-interfaces"
  },"99": {
    "doc": "Implementing Interfaces",
    "title": "Next Steps",
    "content": "After implementing these interfaces, you can: . | Set up event listeners to handle Stripe events | Create a subscription checkout flow | Implement API Platform integration | . ",
    "url": "/stripe-symfony/docs/integration/implementing-interfaces/#next-steps",
    
    "relUrl": "/docs/integration/implementing-interfaces/#next-steps"
  },"100": {
    "doc": "Integration",
    "title": "Integration",
    "content": "This section covers how to integrate the Stripe Bundle with your Symfony application, including implementing the required interfaces and setting up event listeners. ",
    "url": "/stripe-symfony/docs/integration",
    
    "relUrl": "/docs/integration"
  },"101": {
    "doc": "Integration",
    "title": "Integration Topics",
    "content": ". | Implementing Interfaces: How to implement the required interfaces in your application entities | Event Listeners: Setting up event listeners to handle Stripe events | Events: Comprehensive reference of all events dispatched by the bundle | API Platform Integration: How to expose Stripe-related functionality through API Platform | Frontend Integration: How to integrate with your frontend application | . ",
    "url": "/stripe-symfony/docs/integration#integration-topics",
    
    "relUrl": "/docs/integration#integration-topics"
  }
}
